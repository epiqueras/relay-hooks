{"version":3,"file":"es-relay-hooks.min.js","sources":["../src/ReactRelayContext.ts","../node_modules/tslib/tslib.es6.js","../src/RelayHooksType.ts","../src/Utils.ts","../src/QueryFetcher.ts","../src/useQueryFetcher.ts","../src/useRelayEnvironment.ts","../src/useQuery.ts","../src/useLazyLoadQuery.ts","../src/loadQuery.ts","../src/usePreloadedQuery.ts","../src/FragmentResolver.ts","../src/useOssFragment.tsx","../src/useFragment.tsx","../src/useMutation.ts","../src/useSubscription.ts","../src/usePagination.ts","../src/useRefetch.ts","../src/useRefetchable.ts","../src/RelayEnvironmentProvider.tsx"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport * as React from 'react';\nimport { __internal } from 'relay-runtime';\n\nconst { createRelayContext } = __internal as any;\n\nexport const ReactRelayContext = createRelayContext(React);\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n    Disposable,\n    OperationType,\n    CacheConfig,\n    GraphQLTaggedNode,\n    Environment,\n    IEnvironment,\n    Variables,\n    PageInfo,\n    Observer,\n    MutationConfig as BaseMutationConfig,\n    MutationParameters,\n} from 'relay-runtime';\nimport {\n    RelayContext,\n    FragmentSpecResolver,\n    Snapshot,\n} from 'relay-runtime/lib/store/RelayStoreTypes';\n\nexport type MutationState<T extends MutationParameters> = {\n    loading: boolean;\n    data: T['response'] | null;\n    error?: Error | null;\n};\n\nexport type MutationNode<T extends MutationParameters> = BaseMutationConfig<T>['mutation'];\n\nexport type MutationConfig<T extends MutationParameters> = Partial<\n    Omit<BaseMutationConfig<T>, 'mutation' | 'onCompleted'>\n> & {\n    onCompleted?(response: T['response']): void;\n};\n\nexport type Mutate<T extends MutationParameters> = (\n    config?: Partial<MutationConfig<T>>,\n) => Promise<T['response']>;\n\nexport type MutationProps<T extends MutationParameters> = MutationConfig<T> & {\n    children: (mutate: Mutate<T>, state: MutationState<T>) => React.ReactNode;\n    mutation: MutationNode<T>;\n    /** if not provided, the context environment will be used. */\n    environment?: Environment;\n};\n\nexport const NETWORK_ONLY = 'network-only';\nexport const STORE_THEN_NETWORK = 'store-and-network';\nexport const STORE_OR_NETWORK = 'store-or-network';\nexport const STORE_ONLY = 'store-only';\n\nexport type FetchPolicy =\n    | typeof STORE_ONLY\n    | typeof STORE_OR_NETWORK\n    | typeof STORE_THEN_NETWORK\n    | typeof NETWORK_ONLY;\n\nexport type ContainerResult = {\n    data: { [key: string]: any };\n    resolver: FragmentSpecResolver;\n};\n\nexport interface RenderProps<T extends OperationType> {\n    error: Error | null;\n    props: T['response'] | null | undefined;\n    retry: (_cacheConfigOverride?: CacheConfig, observer?: Observer<Snapshot>) => void;\n    cached?: boolean;\n}\n\nexport type OperationContextProps = {\n    operation: any;\n    relay: RelayContext;\n};\n\nexport type RefetchOptions = {\n    force?: boolean;\n    fetchPolicy?: FetchPolicy;\n    metadata?: { [key: string]: any };\n};\n\nexport type QueryOptions = {\n    fetchPolicy?: FetchPolicy;\n    fetchKey?: string | number;\n    networkCacheConfig?: CacheConfig;\n    skip?: boolean;\n    fetchObserver?: Observer<Snapshot>;\n};\n\nexport type $Call<Fn extends (...args: any[]) => any> = Fn extends (arg: any) => infer RT\n    ? RT\n    : never;\n\nexport interface KeyType {\n    readonly ' $data'?: unknown;\n}\nexport type ArrayKeyType = ReadonlyArray<{ readonly ' $data'?: ReadonlyArray<unknown> } | null>;\n\nexport type KeyReturnType<T extends KeyType> = (arg: T) => NonNullable<T[' $data']>;\nexport type ArrayKeyReturnType<T extends ArrayKeyType> = (\n    arg: T,\n) => NonNullable<NonNullable<T[0]>[' $data']>[0];\n\nexport type PaginationFunction<Props, TVariables extends Variables = Variables> = {\n    loadMore: (\n        connectionConfig: ConnectionConfig<Props>,\n        pageSize: number,\n        observerOrCallback?: ObserverOrCallback,\n        options?: RefetchOptions,\n    ) => Disposable;\n    hasMore: (connectionConfig?: ConnectionConfig<Props>) => boolean;\n    isLoading: () => boolean;\n    refetchConnection: (\n        connectionConfig: ConnectionConfig<Props>,\n        totalCount: number,\n        observerOrCallback?: ObserverOrCallback,\n        refetchVariables?: TVariables,\n    ) => Disposable;\n};\n\nexport type RefetchableFunction<TVariables extends Variables = Variables> = (\n    refetchVariables: TVariables | ((fragmentVariables: TVariables) => TVariables),\n    options?: {\n        renderVariables?: TVariables;\n        observerOrCallback?: ObserverOrCallback;\n        refetchOptions?: RefetchOptions;\n    },\n) => Disposable;\n\nexport type RefetchFunction<TVariables extends Variables = Variables> = (\n    taggedNode: GraphQLTaggedNode,\n    refetchVariables: TVariables | ((fragmentVariables: TVariables) => TVariables),\n    renderVariables?: TVariables,\n    observerOrCallback?: ObserverOrCallback,\n    options?: RefetchOptions,\n) => Disposable;\n\nexport type ObserverOrCallback = Observer<void> | ((error?: Error | null | undefined) => void);\n\n// pagination\n\nexport const FORWARD = 'forward';\n\nexport type FragmentVariablesGetter = (prevVars: Variables, totalCount: number) => Variables;\n\nexport interface ConnectionConfig<Props = object> {\n    direction?: 'backward' | 'forward';\n    getConnectionFromProps?: (props: Props) => ConnectionData | null | undefined;\n    getFragmentVariables?: (prevVars: Variables, totalCount: number) => Variables;\n    getVariables: (\n        props: Props,\n        paginationInfo: { count: number; cursor?: string | null },\n        fragmentVariables: Variables,\n    ) => Variables;\n    query: GraphQLTaggedNode;\n}\nexport interface ConnectionData {\n    edges?: ReadonlyArray<any> | null;\n    pageInfo?: Partial<PageInfo> | null;\n}\n\nexport type PaginationData = {\n    direction: string;\n    getConnectionFromProps: Function;\n    getFragmentVariables: Function;\n};\n\nexport type LoadQuery<\n    TOperationType extends OperationType = OperationType,\n    TEnvironment extends IEnvironment = IEnvironment\n> = {\n    next: (\n        environment: TEnvironment,\n        gqlQuery: GraphQLTaggedNode,\n        variables?: TOperationType['variables'],\n        options?: QueryOptions,\n    ) => Promise<void>;\n    subscribe: (callback: (value: any) => any) => () => void;\n    getValue: (environment?: TEnvironment) => RenderProps<TOperationType> | Promise<any>;\n    dispose: () => void;\n};\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as warning from 'fbjs/lib/warning';\nimport {\n    Observer,\n    Variables,\n    ConnectionMetadata,\n    ConnectionInterface,\n    createRequestDescriptor,\n    createReaderSelector,\n    createOperationDescriptor,\n    getRequest,\n    GraphQLTaggedNode,\n    OperationDescriptor,\n    SingularReaderSelector,\n} from 'relay-runtime';\nimport {\n    STORE_OR_NETWORK,\n    STORE_THEN_NETWORK,\n    NETWORK_ONLY,\n    FetchPolicy,\n    FragmentVariablesGetter,\n    FORWARD,\n    PaginationData,\n    ConnectionConfig,\n    ObserverOrCallback,\n} from './RelayHooksType';\n\nexport type ReactConnectionMetadata = ConnectionMetadata & { fragmentName: string };\n\nexport const isNetworkPolicy = (policy: FetchPolicy, storeSnapshot): boolean => {\n    return (\n        policy === NETWORK_ONLY ||\n        policy === STORE_THEN_NETWORK ||\n        (policy === STORE_OR_NETWORK && !storeSnapshot)\n    );\n};\n\nexport const isStorePolicy = (policy: FetchPolicy): boolean => {\n    return policy !== NETWORK_ONLY;\n};\n\n// Fetcher\nexport function createOperation(\n    gqlQuery: GraphQLTaggedNode,\n    variables: Variables,\n): OperationDescriptor {\n    return createOperationDescriptor(getRequest(gqlQuery), variables);\n}\n\n// pagination utils\n\nexport function findConnectionMetadata(fragment): ReactConnectionMetadata {\n    let foundConnectionMetadata = null;\n    let isRelayModern = false;\n    // for (const fragmentName in fragments) {\n    //   const fragment = fragments[fragmentName];\n    const connectionMetadata: Array<ConnectionMetadata> =\n        fragment.metadata && (fragment.metadata.connection as any);\n    // HACK: metadata is always set to `undefined` in classic. In modern, even\n    // if empty, it is set to null (never undefined). We use that knowlege to\n    // check if we're dealing with classic or modern\n    if (fragment.metadata !== undefined) {\n        isRelayModern = true;\n    }\n    if (connectionMetadata) {\n        invariant(\n            connectionMetadata.length === 1,\n            'ReactRelayPaginationContainer: Only a single @connection is ' +\n                'supported, `%s` has %s.',\n            fragment.name,\n            connectionMetadata.length,\n        );\n        invariant(\n            !foundConnectionMetadata,\n            'ReactRelayPaginationContainer: Only a single fragment with ' +\n                '@connection is supported.',\n        );\n        foundConnectionMetadata = {\n            ...connectionMetadata[0],\n            fragmentName: fragment.name,\n        };\n    }\n    //}\n    invariant(\n        !isRelayModern || foundConnectionMetadata !== null,\n        'ReactRelayPaginationContainer: A @connection directive must be present.',\n    );\n    return foundConnectionMetadata || ({} as any);\n}\n\nexport function createGetConnectionFromProps(metadata: ReactConnectionMetadata): any {\n    const path = metadata.path;\n    invariant(\n        path,\n        'ReactRelayPaginationContainer: Unable to synthesize a ' +\n            'getConnectionFromProps function.',\n    );\n    return (props): any => {\n        let data = props;\n        for (let i = 0; i < path.length; i++) {\n            if (!data || typeof data !== 'object') {\n                return null;\n            }\n            data = data[path[i]];\n        }\n        return data;\n    };\n}\n\nexport function createGetFragmentVariables(\n    metadata: ReactConnectionMetadata,\n): FragmentVariablesGetter {\n    const countVariable = metadata.count;\n    invariant(\n        countVariable,\n        'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getFragmentVariables function.',\n    );\n    return (prevVars: Variables, totalCount: number): Variables => ({\n        ...prevVars,\n        [countVariable]: totalCount,\n    });\n}\n\n/*eslint-disable */\nexport function toObserver(observerOrCallback: ObserverOrCallback): Observer<void> {\n    return typeof observerOrCallback === 'function'\n        ? {\n              error: observerOrCallback,\n              complete: observerOrCallback,\n              unsubscribe: (subscription): void => {\n                  typeof observerOrCallback === 'function' && observerOrCallback();\n              },\n          }\n        : observerOrCallback || ({} as any);\n}\n/*eslint-enable */\nexport function getPaginationData(paginationData, fragment): PaginationData {\n    if (!paginationData) {\n        const metadata = findConnectionMetadata(fragment);\n        const getConnectionFromProps = createGetConnectionFromProps(metadata);\n        const direction = metadata.direction;\n        invariant(\n            direction,\n            'ReactRelayPaginationContainer: Unable to infer direction of the ' +\n                'connection, possibly because both first and last are provided.',\n        );\n\n        const getFragmentVariables = createGetFragmentVariables(metadata);\n\n        return {\n            direction,\n            getConnectionFromProps,\n            getFragmentVariables,\n        };\n    }\n    return paginationData;\n}\n\nexport function getNewSelector(request, s, variables): SingularReaderSelector {\n    if (areEqual(variables, s.variables)) {\n        // If we're not actually setting new variables, we don't actually want\n        // to create a new fragment owner, since areEqualSelectors relies on\n        // owner identity.\n        // In fact, we don't even need to try to attempt to set a new selector.\n        // When fragment ownership is not enabled, setSelector will also bail\n        // out since the selector doesn't really change, so we're doing it here\n        // earlier.\n        return s;\n    }\n    // NOTE: We manually create the request descriptor here instead of\n    // calling createOperationDescriptor() because we want to set a\n    // descriptor with *unaltered* variables as the fragment owner.\n    // This is a hack that allows us to preserve exisiting (broken)\n    // behavior of RelayModern containers while using fragment ownership\n    // to propagate variables instead of Context.\n    // For more details, see the summary of D13999308\n    const requestDescriptor = createRequestDescriptor(request, variables);\n    const selector = createReaderSelector(s.node, s.dataID, variables, requestDescriptor);\n    return selector;\n}\n\nexport function _getConnectionData(\n    { direction, getConnectionFromProps: defaultGetConnectionFromProps }: PaginationData,\n    props: any,\n    connectionConfig?: ConnectionConfig,\n): {\n    cursor: string;\n    edgeCount: number;\n    hasMore: boolean;\n} {\n    // Extract connection data and verify there are more edges to fetch\n    const getConnectionFromProps =\n        connectionConfig && connectionConfig.getConnectionFromProps\n            ? connectionConfig.getConnectionFromProps\n            : defaultGetConnectionFromProps; // todo\n    const connectionData = getConnectionFromProps(props);\n    if (connectionData == null) {\n        return null;\n    }\n    const {\n        EDGES,\n        PAGE_INFO,\n        HAS_NEXT_PAGE,\n        HAS_PREV_PAGE,\n        END_CURSOR,\n        START_CURSOR,\n    } = ConnectionInterface.get();\n\n    invariant(\n        typeof connectionData === 'object',\n        'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' +\n            'to return `null` or a plain object with %s and %s properties, got `%s`.',\n        'useFragment pagination',\n        EDGES,\n        PAGE_INFO,\n        connectionData,\n    );\n    const edges = connectionData[EDGES];\n    const pageInfo = connectionData[PAGE_INFO];\n    if (edges == null || pageInfo == null) {\n        return null;\n    }\n    invariant(\n        Array.isArray(edges),\n        'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' +\n            'to return an object with %s: Array, got `%s`.',\n        'useFragment pagination',\n        EDGES,\n        edges,\n    );\n    invariant(\n        typeof pageInfo === 'object',\n        'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' +\n            'to return an object with %s: Object, got `%s`.',\n        'useFragment pagination',\n        PAGE_INFO,\n        pageInfo,\n    );\n    const hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];\n    const cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];\n    if (typeof hasMore !== 'boolean' || (edges.length !== 0 && typeof cursor === 'undefined')) {\n        warning(\n            false,\n            'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' +\n                'Be sure to fetch %s (got `%s`) and %s (got `%s`).',\n            PAGE_INFO,\n            'useFragment pagination',\n            direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE,\n            hasMore,\n            direction === FORWARD ? END_CURSOR : START_CURSOR,\n            cursor,\n        );\n        return null;\n    }\n    return {\n        cursor,\n        edgeCount: edges.length,\n        hasMore,\n    };\n}\n\n/*eslint-disable */\nexport function getRootVariablesForSelector(selector): Variables {\n    return selector != null && selector.kind === 'PluralReaderSelector'\n        ? selector.selectors[0]\n            ? selector.selectors[0].owner.variables\n            : {}\n        : selector\n        ? selector.owner.variables\n        : {};\n}\n","import {\n    Disposable,\n    CacheConfig,\n    IEnvironment,\n    Snapshot,\n    __internal,\n    OperationType,\n    OperationDescriptor,\n    Observer,\n} from 'relay-runtime';\nimport { FetchPolicy, RenderProps, QueryOptions } from './RelayHooksType';\nimport { isNetworkPolicy, isStorePolicy } from './Utils';\n\nconst { fetchQuery } = __internal;\n\nconst defaultPolicy = 'store-or-network';\n\nconst cache: Map<string, QueryFetcher<any>> = new Map();\n\nexport function getOrCreateQueryFetcher<TOperationType extends OperationType>(\n    query: OperationDescriptor | null,\n    forceUpdate: any,\n): QueryFetcher<TOperationType> {\n    const suspense = !!query;\n    const queryFetcher =\n        suspense && cache.has(query.request.identifier)\n            ? cache.get(query.request.identifier)\n            : new QueryFetcher(suspense, suspense);\n    queryFetcher.setForceUpdate(forceUpdate);\n    return queryFetcher;\n}\n\nconst DATA_RETENTION_TIMEOUT = 30 * 1000;\n\nexport class QueryFetcher<TOperationType extends OperationType = OperationType> {\n    environment: IEnvironment;\n    query: OperationDescriptor;\n    networkSubscription: Disposable;\n    rootSubscription: Disposable;\n    error: Error | null;\n    snapshot: Snapshot;\n    fetchPolicy: FetchPolicy;\n    fetchKey: string | number;\n    disposableRetain: Disposable;\n    forceUpdate: (_o: any) => void;\n    suspense: boolean;\n    useLazy: boolean;\n    releaseQueryTimeout;\n\n    constructor(suspense = false, useLazy = false) {\n        this.suspense = suspense;\n        this.useLazy = suspense && useLazy;\n        this.setForceUpdate(() => undefined);\n    }\n\n    setForceUpdate(forceUpdate): void {\n        this.forceUpdate = forceUpdate;\n    }\n\n    dispose(): void {\n        this.disposeRequest();\n        this.disposeRetain();\n    }\n\n    disposeRetain(): void {\n        this.clearTemporaryRetain();\n        this.disposableRetain && this.disposableRetain.dispose();\n        this.query && cache.delete(this.query.request.identifier);\n    }\n\n    clearTemporaryRetain(): void {\n        clearTimeout(this.releaseQueryTimeout);\n        this.releaseQueryTimeout = null;\n    }\n\n    temporaryRetain(): void {\n        const localReleaseTemporaryRetain = (): void => {\n            this.dispose();\n        };\n        this.releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT);\n    }\n\n    isDiffEnvQuery(environment: IEnvironment, query): boolean {\n        return (\n            environment !== this.environment ||\n            query.request.identifier !== this.query.request.identifier\n        );\n    }\n\n    lookupInStore(environment: IEnvironment, operation, fetchPolicy: FetchPolicy): Snapshot {\n        if (isStorePolicy(fetchPolicy)) {\n            const check: any = environment.check(operation);\n            if (check === 'available' || check.status === 'available') {\n                return environment.lookup(operation.fragment);\n            }\n        }\n        return null;\n    }\n\n    execute(\n        environment: IEnvironment,\n        query: OperationDescriptor,\n        options: QueryOptions,\n        retain: (environment, query) => Disposable = (environment, query): Disposable =>\n            environment.retain(query),\n    ): RenderProps<TOperationType> {\n        const {\n            fetchPolicy = defaultPolicy,\n            networkCacheConfig,\n            fetchKey,\n            skip,\n            fetchObserver,\n        } = options;\n        let storeSnapshot;\n        const retry = (\n            cacheConfigOverride: CacheConfig = networkCacheConfig,\n            observer?: Observer<Snapshot>,\n        ): void => {\n            this.disposeRequest();\n            this.fetch(cacheConfigOverride, false, observer);\n        };\n        if (skip) {\n            return {\n                cached: false,\n                retry,\n                error: null,\n                props: undefined,\n            };\n        }\n        this.clearTemporaryRetain();\n        const isDiffEnvQuery = this.isDiffEnvQuery(environment, query);\n        if (isDiffEnvQuery || fetchPolicy !== this.fetchPolicy || fetchKey !== this.fetchKey) {\n            if (isDiffEnvQuery) {\n                this.disposeRetain();\n                this.useLazy && cache.set(query.request.identifier, this);\n                this.disposableRetain = retain(environment, query);\n            }\n            this.environment = environment;\n            this.query = query;\n            this.fetchPolicy = fetchPolicy;\n            this.fetchKey = fetchKey;\n            this.disposeRequest();\n\n            storeSnapshot = this.lookupInStore(environment, this.query, fetchPolicy);\n            const isNetwork = isNetworkPolicy(fetchPolicy, storeSnapshot);\n            if (isNetwork) {\n                this.fetch(networkCacheConfig, this.suspense && !storeSnapshot, fetchObserver);\n            } else if (!!storeSnapshot) {\n                this.snapshot = storeSnapshot;\n                this.error = null;\n                this.subscribe(storeSnapshot);\n            }\n        }\n\n        const resultSnapshot = storeSnapshot || this.snapshot;\n        return {\n            cached: !!storeSnapshot,\n            retry,\n            error: this.error,\n            props: resultSnapshot ? resultSnapshot.data : null,\n        };\n    }\n\n    subscribe(snapshot): void {\n        if (this.rootSubscription) {\n            this.rootSubscription.dispose();\n        }\n        this.rootSubscription = this.environment.subscribe(snapshot, (snapshot) => {\n            // Read from this._fetchOptions in case onDataChange() was lazily added.\n            this.snapshot = snapshot;\n            this.error = null;\n            this.forceUpdate(snapshot);\n        });\n    }\n\n    fetch(networkCacheConfig, suspense: boolean, observer = {} as Observer<Snapshot>): void {\n        let fetchHasReturned = false;\n        let resolveNetworkPromise = (): void => {};\n        fetchQuery(this.environment, this.query, {\n            networkCacheConfig:\n                suspense && !networkCacheConfig ? { force: true } : networkCacheConfig,\n        }).subscribe({\n            start: (subscription) => {\n                this.networkSubscription = {\n                    dispose: (): void => subscription.unsubscribe(),\n                };\n                observer.start && observer.start(subscription);\n            },\n            next: () => {\n                this.error = null;\n                this._onQueryDataAvailable({\n                    notifyFirstResult: fetchHasReturned,\n                    suspense,\n                    observer,\n                });\n                resolveNetworkPromise();\n            },\n            error: (error) => {\n                this.error = error;\n                this.snapshot = null;\n                if (fetchHasReturned && !suspense) {\n                    this.forceUpdate(error);\n                }\n                resolveNetworkPromise();\n                this.networkSubscription = null;\n                observer.error && observer.error(error);\n            },\n            complete: () => {\n                this.networkSubscription = null;\n                observer.complete && observer.complete();\n            },\n            unsubscribe: (subscription) => {\n                if (this.useLazy && !this.rootSubscription && this.releaseQueryTimeout) {\n                    this.dispose();\n                }\n                observer.unsubscribe && observer.unsubscribe(subscription);\n            },\n        });\n        fetchHasReturned = true;\n        if (suspense) {\n            if (this.useLazy) {\n                this.setForceUpdate(() => undefined);\n                this.temporaryRetain();\n            }\n            throw new Promise((resolve) => {\n                resolveNetworkPromise = resolve;\n            });\n        }\n    }\n\n    disposeRequest(): void {\n        this.error = null;\n        this.snapshot = null;\n        if (this.networkSubscription) {\n            this.networkSubscription.dispose();\n            this.networkSubscription = null;\n        }\n        if (this.rootSubscription) {\n            this.rootSubscription.dispose();\n            this.rootSubscription = null;\n        }\n    }\n\n    _onQueryDataAvailable({\n        notifyFirstResult,\n        suspense,\n        observer,\n    }: {\n        notifyFirstResult: boolean;\n        suspense: boolean;\n        observer: Observer<Snapshot>;\n    }): void {\n        // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n        // multiple times by network layers that support data subscriptions.\n        // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n\n        if (this.snapshot) {\n            return;\n        }\n\n        this.snapshot = this.environment.lookup(this.query.fragment);\n\n        // Subscribe to changes in the data of the root fragment\n        this.subscribe(this.snapshot);\n\n        observer.next && observer.next(this.snapshot);\n\n        if (this.snapshot && notifyFirstResult && !suspense) {\n            this.forceUpdate(this.snapshot);\n        }\n    }\n}\n","import { useState, useEffect, useRef } from 'react';\nimport { OperationType, OperationDescriptor } from 'relay-runtime';\nimport { QueryFetcher, getOrCreateQueryFetcher } from './QueryFetcher';\n\nexport type Reference<TOperationType extends OperationType = OperationType> = {\n    queryFetcher: QueryFetcher<TOperationType>;\n};\n\n// set query when you want suspends\nexport const useQueryFetcher = <TOperationType extends OperationType>(\n    query?: OperationDescriptor,\n): QueryFetcher<TOperationType> => {\n    const [, forceUpdate] = useState(null);\n    const ref = useRef<Reference<TOperationType>>();\n    if (ref.current === null || ref.current === undefined) {\n        ref.current = {\n            queryFetcher: getOrCreateQueryFetcher(query, forceUpdate),\n        };\n    }\n    //const { queryFetcher } = ref.current;\n\n    useEffect(() => {\n        return (): void => ref.current.queryFetcher.dispose();\n    }, []);\n    return ref.current.queryFetcher;\n};\n","import * as React from 'react';\nimport { IEnvironment } from 'relay-runtime';\nimport { ReactRelayContext } from './ReactRelayContext';\n\nexport function useRelayEnvironment<\n    TEnvironment extends IEnvironment = IEnvironment\n>(): TEnvironment {\n    const { environment } = React.useContext(ReactRelayContext);\n    return environment;\n}\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport { useRef, useMemo } from 'react';\nimport { GraphQLTaggedNode, OperationType, OperationDescriptor, Variables } from 'relay-runtime';\nimport { RenderProps, QueryOptions } from './RelayHooksType';\nimport { useQueryFetcher } from './useQueryFetcher';\nimport { useRelayEnvironment } from './useRelayEnvironment';\nimport { createOperation } from './Utils';\n\nexport function useDeepCompare<T>(value: T): T {\n    const latestValue = useRef(value);\n    if (!areEqual(latestValue.current, value)) {\n        latestValue.current = value;\n    }\n    return latestValue.current;\n}\n\nexport function useMemoOperationDescriptor(\n    gqlQuery: GraphQLTaggedNode,\n    variables: Variables,\n): OperationDescriptor {\n    const memoVariables = useDeepCompare(variables);\n    return useMemo(() => createOperation(gqlQuery, memoVariables), [gqlQuery, memoVariables]);\n}\n\nexport const useQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'] = {},\n    options: QueryOptions = {},\n): RenderProps<TOperationType> => {\n    const environment = useRelayEnvironment();\n    const query = useMemoOperationDescriptor(gqlQuery, variables);\n    const queryFetcher = useQueryFetcher<TOperationType>();\n\n    return queryFetcher.execute(environment, query, options);\n};\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport { RenderProps, QueryOptions } from './RelayHooksType';\nimport { useMemoOperationDescriptor } from './useQuery';\nimport { useQueryFetcher } from './useQueryFetcher';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport const useLazyLoadQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'] = {},\n    options: QueryOptions = {},\n): RenderProps<TOperationType> => {\n    const environment = useRelayEnvironment();\n    const query = useMemoOperationDescriptor(gqlQuery, variables);\n    const queryFetcher = useQueryFetcher<TOperationType>(query);\n    return queryFetcher.execute(environment, query, options);\n};\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport {\n    GraphQLTaggedNode,\n    OperationType,\n    IEnvironment,\n    isPromise,\n    OperationDescriptor,\n    Disposable,\n} from 'relay-runtime';\nimport { QueryFetcher } from './QueryFetcher';\nimport { RenderProps, QueryOptions, LoadQuery } from './RelayHooksType';\nimport { createOperation } from './Utils';\n\nexport const internalLoadQuery = <TOperationType extends OperationType = OperationType>(\n    promise = false,\n    queryExecute = (\n        queryFetcher: QueryFetcher<TOperationType>,\n        environment: IEnvironment,\n        query: OperationDescriptor,\n        options: QueryOptions,\n        retain?: (environment, query) => Disposable,\n    ): RenderProps<TOperationType> => queryFetcher.execute(environment, query, options, retain),\n): LoadQuery<TOperationType> => {\n    let data: RenderProps<TOperationType> | null | Promise<any> = null;\n    let listener = undefined;\n    let queryFetcher = new QueryFetcher<TOperationType>(true);\n\n    let prev = {\n        environment: null,\n        gqlQuery: null,\n        variables: null,\n        options: null,\n        query: null,\n    };\n\n    const dispose = (): void => {\n        queryFetcher.dispose();\n        queryFetcher = new QueryFetcher<TOperationType>(true);\n        listener = undefined;\n        data = null;\n        prev = {\n            environment: null,\n            gqlQuery: null,\n            variables: null,\n            options: null,\n            query: null,\n        };\n    };\n\n    const next = (\n        environment,\n        gqlQuery: GraphQLTaggedNode,\n        variables: TOperationType['variables'] = {},\n        options: QueryOptions = {},\n    ): Promise<void> => {\n        prev.environment = environment;\n        prev.options = options;\n        if (!areEqual(variables, prev.variables) || gqlQuery != prev.gqlQuery) {\n            prev.variables = variables;\n            prev.gqlQuery = gqlQuery;\n            prev.query = createOperation(gqlQuery, prev.variables);\n        }\n        const execute = (): void => {\n            data = queryExecute(queryFetcher, prev.environment, prev.query, prev.options);\n            listener && listener(data);\n        };\n\n        queryFetcher.setForceUpdate(execute);\n        let result;\n        try {\n            execute();\n        } catch (e) {\n            result = e.then(execute);\n            if (promise) {\n                data = result;\n            } else {\n                execute();\n            }\n        }\n        return result ?? Promise.resolve();\n    };\n\n    const getValue = (\n        environment?: IEnvironment,\n    ): RenderProps<TOperationType> | null | Promise<any> => {\n        if (environment && environment != prev.environment) {\n            next(environment, prev.gqlQuery, prev.variables, prev.options);\n        }\n        if (isPromise(data)) {\n            throw data;\n        }\n\n        return data;\n    };\n\n    const subscribe = (callback: (value) => any): (() => void) => {\n        listener = callback;\n        return (): void => {\n            if (listener === callback) {\n                listener = null;\n            }\n        };\n    };\n    return {\n        next,\n        subscribe,\n        getValue,\n        dispose,\n    };\n};\n\nexport const loadLazyQuery = <\n    TOperationType extends OperationType = OperationType\n>(): LoadQuery<TOperationType> => {\n    return internalLoadQuery(true);\n};\n\nexport const loadQuery = <\n    TOperationType extends OperationType = OperationType\n>(): LoadQuery<TOperationType> => {\n    return internalLoadQuery(false);\n};\n","import { useState, useEffect } from 'react';\nimport { OperationType } from 'relay-runtime';\nimport { RenderProps, LoadQuery } from './RelayHooksType';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport const usePreloadedQuery = <TOperationType extends OperationType = OperationType>(\n    loadQuery: LoadQuery,\n): RenderProps<TOperationType> => {\n    const [, forceUpdate] = useState();\n    const environment = useRelayEnvironment();\n\n    useEffect(() => {\n        const dispose = loadQuery.subscribe(forceUpdate);\n        return (): void => dispose();\n    }, [loadQuery]);\n\n    return loadQuery.getValue(environment) as RenderProps<TOperationType>;\n};\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport * as invariant from 'fbjs/lib/invariant';\nimport {\n    getSelector,\n    IEnvironment,\n    Disposable,\n    Snapshot,\n    getFragment,\n    Variables,\n    getVariablesFromFragment,\n    GraphQLTaggedNode,\n    Observable,\n    Observer,\n    OperationDescriptor,\n    CacheConfig,\n    Subscription,\n    getDataIDsFromFragment,\n    PluralReaderSelector,\n    __internal,\n    ReaderSelector,\n} from 'relay-runtime';\nimport {\n    RefetchOptions,\n    PaginationData,\n    ConnectionConfig,\n    ObserverOrCallback,\n} from './RelayHooksType';\nimport {\n    isNetworkPolicy,\n    isStorePolicy,\n    getPaginationData,\n    _getConnectionData,\n    toObserver,\n    getRootVariablesForSelector,\n    getNewSelector,\n    createOperation,\n} from './Utils';\n\nconst { fetchQuery } = __internal;\n\ntype SingularOrPluralSnapshot = Snapshot | Array<Snapshot>;\n\nfunction lookupFragment(environment, selector): SingularOrPluralSnapshot {\n    return selector.kind === 'PluralReaderSelector'\n        ? selector.selectors.map((s) => environment.lookup(s))\n        : environment.lookup(selector);\n}\n\nfunction getFragmentResult(snapshot: SingularOrPluralSnapshot): any {\n    if (Array.isArray(snapshot)) {\n        return { snapshot, data: snapshot.map((s) => s.data) };\n    }\n    return { snapshot, data: snapshot.data };\n}\n\ntype FragmentResult = {\n    snapshot: SingularOrPluralSnapshot | null;\n    data: any;\n};\n\nexport class FragmentResolver {\n    _environment: IEnvironment;\n    _fragment: any;\n    _fragmentNode: any;\n    _fragmentRef: any;\n    _result: FragmentResult;\n    _disposable: Disposable = { dispose: () => {} };\n    _selector: ReaderSelector;\n    _forceUpdate: any;\n    _isPlural: boolean;\n    _refetchSubscription: Subscription;\n    paginationData: PaginationData;\n    _refetchVariables: Variables;\n    _isARequestInFlight = false;\n    _selectionReferences: Array<Disposable> = [];\n    _cacheSelectionReference: Disposable;\n    indexUpdate = 0;\n\n    constructor(forceUpdate) {\n        this._forceUpdate = forceUpdate;\n    }\n\n    refreshHooks(): void {\n        this.indexUpdate += 1;\n        this._forceUpdate(this.indexUpdate);\n    }\n\n    dispose(): void {\n        this._disposable && this._disposable.dispose();\n        this._refetchSubscription && this._refetchSubscription.unsubscribe();\n        this._refetchSubscription = null;\n        this.disposeSelectionReferences();\n\n        this._isARequestInFlight = false;\n    }\n\n    disposeSelectionReferences(): void {\n        this._disposeCacheSelectionReference();\n        this._selectionReferences.forEach((r) => r.dispose());\n        this._selectionReferences = [];\n    }\n\n    _retainCachedOperation(operation: OperationDescriptor): void {\n        this._disposeCacheSelectionReference();\n        this._cacheSelectionReference = this._environment.retain(operation);\n    }\n\n    _disposeCacheSelectionReference(): void {\n        this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n        this._cacheSelectionReference = null;\n    }\n\n    getFragmentVariables(fRef = this._fragmentRef): Variables {\n        return getVariablesFromFragment(this._fragment, fRef);\n    }\n\n    changedFragmentRef(fragmentRef): boolean {\n        if (this._fragmentRef !== fragmentRef) {\n            const prevIDs = getDataIDsFromFragment(this._fragment, this._fragmentRef);\n            const nextIDs = getDataIDsFromFragment(this._fragment, fragmentRef);\n\n            if (\n                !areEqual(prevIDs, nextIDs) ||\n                !areEqual(\n                    this.getFragmentVariables(fragmentRef),\n                    this.getFragmentVariables(this._fragmentRef),\n                )\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    resolve(environment: IEnvironment, fragmentNode, fragmentRef): void {\n        if (this._fragmentNode !== fragmentNode) {\n            this._fragment = getFragment(fragmentNode);\n            this.paginationData = null;\n        }\n        if (\n            this._environment !== environment ||\n            this._fragmentNode !== fragmentNode ||\n            this.changedFragmentRef(fragmentRef)\n        ) {\n            this._environment = environment;\n            this._fragmentNode = fragmentNode;\n            this._fragmentRef = fragmentRef;\n            this._result = null;\n            this.dispose();\n            if (this._fragmentRef == null) {\n                this._result = { data: null, snapshot: null };\n            }\n\n            // If fragmentRef is plural, ensure that it is an array.\n            // If it's empty, return the empty array direclty before doing any more work.\n            this._isPlural =\n                this._fragment.metadata &&\n                this._fragment.metadata.plural &&\n                this._fragment.metadata.plural === true;\n            if (this._isPlural) {\n                if (this._fragmentRef.length === 0) {\n                    this._result = { data: [], snapshot: [] };\n                }\n            }\n\n            if (!this._result) {\n                this._selector = getSelector(this._fragment, this._fragmentRef);\n                this.lookup();\n            }\n        }\n    }\n\n    lookup(): void {\n        const snapshot = lookupFragment(this._environment, this._selector);\n\n        // if (!isMissingData(snapshot)) { this for promises\n        this._result = getFragmentResult(snapshot);\n        this.subscribe();\n    }\n\n    getData(): any | null {\n        return this._result ? this._result.data : null;\n    }\n\n    subscribe(): void {\n        const environment = this._environment;\n        const renderedSnapshot = this._result.snapshot;\n\n        this._disposable && this._disposable.dispose();\n        if (!renderedSnapshot) {\n            this._disposable = { dispose: (): void => {} };\n        }\n\n        const dataSubscriptions = [];\n\n        if (Array.isArray(renderedSnapshot)) {\n            renderedSnapshot.forEach((snapshot, idx) => {\n                dataSubscriptions.push(\n                    environment.subscribe(snapshot, (latestSnapshot) => {\n                        this._result.snapshot[idx] = latestSnapshot;\n                        this._result.data[idx] = latestSnapshot.data;\n                        this.refreshHooks();\n                    }),\n                );\n            });\n        } else {\n            dataSubscriptions.push(\n                environment.subscribe(renderedSnapshot, (latestSnapshot) => {\n                    this._result = getFragmentResult(latestSnapshot);\n                    this.refreshHooks();\n                }),\n            );\n        }\n\n        this._disposable = {\n            dispose: (): void => {\n                dataSubscriptions.map((s) => s.dispose());\n            },\n        };\n    }\n\n    changeVariables(variables, request): void {\n        if (this._selector.kind === 'PluralReaderSelector') {\n            (this._selector as any).selectors = (this\n                ._selector as PluralReaderSelector).selectors.map((s) =>\n                getNewSelector(request, s, variables),\n            );\n        } else {\n            this._selector = getNewSelector(request, this._selector, variables);\n        }\n        this.lookup();\n    }\n\n    lookupInStore(environment: IEnvironment, operation, fetchPolicy): Snapshot | null {\n        if (isStorePolicy(fetchPolicy)) {\n            const check: any = environment.check(operation);\n            if (check === 'available' || check.status === 'available') {\n                this._retainCachedOperation(operation);\n                return environment.lookup(operation.fragment);\n            }\n        }\n        return null;\n    }\n\n    refetch = (\n        taggedNode: GraphQLTaggedNode,\n        refetchVariables: Variables | ((fragmentVariables: Variables) => Variables),\n        renderVariables: Variables,\n        observerOrCallback: ObserverOrCallback,\n        options: RefetchOptions,\n    ): Disposable => {\n        //TODO Function\n        const fragmentVariables = this.getFragmentVariables();\n        const fetchVariables =\n            typeof refetchVariables === 'function'\n                ? refetchVariables(fragmentVariables)\n                : refetchVariables;\n        const newFragmentVariables = renderVariables\n            ? { ...fetchVariables, ...renderVariables }\n            : fetchVariables;\n\n        /*eslint-disable */\n        const observer =\n            typeof observerOrCallback === 'function'\n                ? {\n                      next: observerOrCallback,\n                      error: observerOrCallback,\n                  }\n                : observerOrCallback || ({} as any);\n\n        /*eslint-enable */\n        const onNext = (operation, payload, complete): void => {\n            this.changeVariables(newFragmentVariables, operation.request.node);\n            this.refreshHooks();\n            complete();\n        };\n\n        return this.executeFetcher(taggedNode, fetchVariables, options, observer, onNext);\n    };\n\n    // pagination\n\n    isLoading = (): boolean => {\n        return !!this._refetchSubscription;\n    };\n\n    hasMore = (connectionConfig?: ConnectionConfig): boolean => {\n        this.paginationData = getPaginationData(this.paginationData, this._fragment);\n        const connectionData = _getConnectionData(\n            this.paginationData,\n            this.getData(),\n            connectionConfig,\n        );\n        return !!(connectionData && connectionData.hasMore && connectionData.cursor);\n    };\n\n    refetchConnection = (\n        connectionConfig: ConnectionConfig,\n        totalCount: number,\n        observerOrCallback?: ObserverOrCallback,\n        refetchVariables?: Variables,\n    ): Disposable => {\n        this.paginationData = getPaginationData(this.paginationData, this._fragment);\n\n        this._refetchVariables = refetchVariables;\n        const paginatingVariables = {\n            count: totalCount,\n            cursor: null,\n            totalCount,\n        };\n        return this._fetchPage(\n            connectionConfig,\n            paginatingVariables,\n            toObserver(observerOrCallback),\n            { force: true },\n        );\n    };\n\n    loadMore = (\n        connectionConfig: ConnectionConfig,\n        pageSize: number,\n        observerOrCallback?: ObserverOrCallback,\n        options?: RefetchOptions,\n    ): Disposable => {\n        this.paginationData = getPaginationData(this.paginationData, this._fragment);\n\n        const observer = toObserver(observerOrCallback);\n        const connectionData = _getConnectionData(\n            this.paginationData,\n            this.getData(),\n            connectionConfig,\n        );\n\n        if (!connectionData) {\n            Observable.create((sink) => sink.complete()).subscribe(observer);\n            return null;\n        }\n        const totalCount = connectionData.edgeCount + pageSize;\n        if (options && options.force) {\n            return this.refetchConnection(\n                connectionConfig,\n                totalCount,\n                observerOrCallback,\n                undefined,\n            );\n        }\n        //const { END_CURSOR, START_CURSOR } = ConnectionInterface.get();\n        const cursor = connectionData.cursor;\n        /*warning(\n            cursor,\n            'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)',\n            this._direction === FORWARD ? END_CURSOR : START_CURSOR,\n            cursor,\n        );*/\n        const paginatingVariables = {\n            count: pageSize,\n            cursor: cursor,\n            totalCount,\n        };\n        return this._fetchPage(connectionConfig, paginatingVariables, observer, options);\n    };\n\n    _fetchPage(\n        connectionConfig: ConnectionConfig,\n        paginatingVariables: {\n            count: number;\n            cursor: string;\n            totalCount: number;\n        },\n        observer: Observer<void>,\n        options: RefetchOptions,\n    ): Disposable {\n        //const { componentRef: _, __relayContext, ...restProps } = this.props;\n        //const resolver = prevResult.resolver;\n        //const fragments = prevResult.resolver._fragments;\n        const rootVariables = getRootVariablesForSelector(this._selector);\n        // hack 6.0.0\n        let fragmentVariables = {\n            ...rootVariables,\n            ...this.getFragmentVariables(),\n            ...this._refetchVariables,\n        };\n        let fetchVariables = connectionConfig.getVariables(\n            this.getData(),\n            {\n                count: paginatingVariables.count,\n                cursor: paginatingVariables.cursor,\n            },\n            fragmentVariables,\n        );\n        invariant(\n            typeof fetchVariables === 'object' && fetchVariables !== null,\n            'ReactRelayPaginationContainer: Expected `getVariables()` to ' +\n                'return an object, got `%s` in `%s`.',\n            fetchVariables,\n            'useFragment pagination',\n        );\n        fetchVariables = {\n            ...fetchVariables,\n            ...this._refetchVariables,\n        };\n        fragmentVariables = {\n            ...fetchVariables,\n            ...fragmentVariables,\n        };\n\n        const onNext = (operation, payload, complete): void => {\n            const prevData = this.getData();\n\n            const getFragmentVariables =\n                connectionConfig.getFragmentVariables || this.paginationData.getFragmentVariables;\n            this.changeVariables(\n                getFragmentVariables(fragmentVariables, paginatingVariables.totalCount),\n                operation.request.node,\n            );\n\n            const nextData = this.getData();\n\n            // Workaround slightly different handling for connection in different\n            // core implementations:\n            // - Classic core requires the count to be explicitly incremented\n            // - Modern core automatically appends new items, updating the count\n            //   isn't required to see new data.\n            //\n            // `setState` is only required if changing the variables would change the\n            // resolved data.\n            // TODO #14894725: remove PaginationContainer equal check\n\n            if (!areEqual(prevData, nextData)) {\n                this.refreshHooks();\n                const callComplete = async (): Promise<void> => {\n                    complete();\n                };\n                callComplete();\n            } else {\n                complete();\n            }\n        };\n\n        return this.executeFetcher(\n            connectionConfig.query,\n            fetchVariables,\n            options,\n            observer,\n            onNext,\n        );\n    }\n\n    executeFetcher(\n        taggedNode: GraphQLTaggedNode,\n        fetchVariables: Variables,\n        options: RefetchOptions,\n        observerOrCallback: ObserverOrCallback,\n        onNext: (operation, payload, complete) => void,\n    ): Disposable {\n        const cacheConfig: CacheConfig = options ? { force: !!options.force } : undefined;\n        if (cacheConfig != null && options && options.metadata != null) {\n            cacheConfig.metadata = options.metadata;\n        }\n\n        /*eslint-disable */\n        const observer =\n            typeof observerOrCallback === 'function'\n                ? {\n                      next: observerOrCallback,\n                      error: observerOrCallback,\n                  }\n                : observerOrCallback || ({} as any);\n\n        /*eslint-enable */\n\n        const operation = createOperation(taggedNode, fetchVariables);\n\n        const optionsFetch = options ? options : {};\n\n        const { fetchPolicy = 'network-only' } = optionsFetch;\n\n        const storeSnapshot = this.lookupInStore(this._environment, operation, fetchPolicy);\n        if (storeSnapshot != null) {\n            onNext(operation, null, () => {\n                observer.next && observer.next();\n                observer.complete && observer.complete();\n            });\n        }\n        // Cancel any previously running refetch.\n        this._refetchSubscription && this._refetchSubscription.unsubscribe();\n\n        // Declare refetchSubscription before assigning it in .start(), since\n        // synchronous completion may call callbacks .subscribe() returns.\n        let refetchSubscription: Subscription;\n\n        const isNetwork = isNetworkPolicy(fetchPolicy, storeSnapshot);\n        if (!isNetwork) {\n            return {\n                dispose: (): void => {},\n            };\n        }\n        if (isNetwork) {\n            const reference = this._environment.retain(operation);\n\n            /*eslint-disable */\n            const fetchQueryOptions =\n                cacheConfig != null\n                    ? {\n                          networkCacheConfig: cacheConfig,\n                      }\n                    : {};\n\n            /*eslint-enable */\n            const cleanup = (): void => {\n                this._selectionReferences = this._selectionReferences.concat(reference);\n                if (this._refetchSubscription === refetchSubscription) {\n                    this._refetchSubscription = null;\n                    this._isARequestInFlight = false;\n                }\n            };\n\n            this._isARequestInFlight = true;\n            fetchQuery(this._environment, operation, fetchQueryOptions)\n                .mergeMap((payload) => {\n                    return Observable.create((sink) => {\n                        onNext(operation, payload, () => {\n                            sink.next(undefined); // pass void to public observer's `next()`\n                            sink.complete();\n                        });\n                    });\n                })\n                // use do instead of finally so that observer's `complete` fires after cleanup\n                .do({\n                    error: cleanup,\n                    complete: cleanup,\n                    unsubscribe: cleanup,\n                })\n                .subscribe({\n                    ...observer,\n                    start: (subscription) => {\n                        refetchSubscription = subscription;\n                        this._refetchSubscription = this._isARequestInFlight\n                            ? refetchSubscription\n                            : null;\n                        observer.start && observer.start(subscription);\n                    },\n                });\n        }\n\n        return {\n            dispose: (): void => {\n                refetchSubscription && refetchSubscription.unsubscribe();\n            },\n        };\n    }\n}\n","import { useEffect, useState, useRef } from 'react';\nimport { GraphQLTaggedNode } from 'relay-runtime';\nimport { FragmentResolver } from './FragmentResolver';\nimport {\n    ContainerResult,\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n} from './RelayHooksType';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport function useOssFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [$Call<KeyReturnType<TKey>>, FragmentResolver];\nexport function useOssFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [$Call<KeyReturnType<TKey>> | null, FragmentResolver];\nexport function useOssFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>, FragmentResolver];\nexport function useOssFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null, FragmentResolver] {\n    const environment = useRelayEnvironment();\n    const [, forceUpdate] = useState<ContainerResult>(null);\n    const ref = useRef<{ resolver: FragmentResolver }>(null);\n    if (ref.current === null || ref.current === undefined) {\n        ref.current = {\n            resolver: new FragmentResolver(forceUpdate),\n        };\n    }\n\n    const { resolver } = ref.current;\n\n    useEffect(() => {\n        return (): void => {\n            resolver.dispose();\n        };\n    }, [resolver]);\n\n    resolver.resolve(environment, fragmentNode, fragmentRef);\n\n    const data = resolver.getData();\n\n    return [data, resolver];\n}\n","import { GraphQLTaggedNode } from 'relay-runtime';\nimport { KeyType, KeyReturnType, $Call, ArrayKeyType, ArrayKeyReturnType } from './RelayHooksType';\nimport { useOssFragment } from './useOssFragment';\n\nexport function useFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): $Call<KeyReturnType<TKey>>;\nexport function useFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): $Call<KeyReturnType<TKey>> | null;\nexport function useFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>;\nexport function useFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef);\n\n    return data;\n}\n","/*eslint-disable */\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as React from 'react';\nimport { Environment, MutationParameters, commitMutation } from 'relay-runtime';\nimport useMounted from '@restart/hooks/useMounted';\nimport {\n    MutationNode,\n    MutationConfig,\n    MutationState,\n    Mutate,\n    MutationProps,\n} from './RelayHooksType';\nimport { useRelayEnvironment } from './useRelayEnvironment';\nconst { useCallback, useState } = React;\n\nexport function useMutation<T extends MutationParameters>(\n    mutation: MutationNode<T>,\n    userConfig: MutationConfig<T> = {},\n    /** if not provided, the context environment will be used. */\n    environment?: Environment,\n): [Mutate<T>, MutationState<T>] {\n    const [state, setState] = useState<MutationState<T>>({\n        loading: false,\n        data: null,\n        error: null,\n    });\n\n    const isMounted = useMounted();\n\n    const relayEnvironment = useRelayEnvironment();\n    const resolvedEnvironment = environment || relayEnvironment;\n    const {\n        configs,\n        variables,\n        uploadables,\n        onCompleted,\n        onError,\n        optimisticUpdater,\n        optimisticResponse,\n        updater,\n    } = userConfig;\n\n    const mutate: Mutate<T> = useCallback(\n        (config) => {\n            const mergedConfig = {\n                configs,\n                variables,\n                uploadables,\n                onCompleted,\n                onError,\n                optimisticUpdater,\n                optimisticResponse,\n                updater,\n                ...config,\n            };\n\n            invariant(mergedConfig.variables, 'you must specify variables');\n\n            setState({\n                loading: true,\n                data: null,\n                error: null,\n            });\n\n            return new Promise((resolve, reject) => {\n                function handleError(error: any): void {\n                    if (isMounted()) {\n                        setState({\n                            loading: false,\n                            data: null,\n                            error,\n                        });\n                    }\n\n                    if (mergedConfig.onError) {\n                        mergedConfig.onError(error);\n                        resolve();\n                    } else {\n                        reject(error);\n                    }\n                }\n\n                commitMutation(resolvedEnvironment, {\n                    ...mergedConfig,\n                    mutation,\n                    variables: mergedConfig.variables!,\n                    onCompleted: (response, errors) => {\n                        if (errors) {\n                            // FIXME: This isn't right. onError expects a single error.\n                            handleError(errors);\n                            return;\n                        }\n\n                        if (isMounted()) {\n                            setState({\n                                loading: false,\n                                data: response,\n                                error: null,\n                            });\n                        }\n\n                        if (mergedConfig.onCompleted) {\n                            mergedConfig.onCompleted(response);\n                        }\n                        resolve(response);\n                    },\n                    onError: handleError,\n                });\n            });\n        },\n        [\n            resolvedEnvironment,\n            configs,\n            mutation,\n            variables,\n            uploadables,\n            onCompleted,\n            onError,\n            optimisticUpdater,\n            optimisticResponse,\n            updater,\n            isMounted,\n        ],\n    );\n\n    return [mutate, state];\n}\n\nexport function Mutation<T extends MutationParameters>({\n    children,\n    mutation,\n    environment,\n    ...config\n}: MutationProps<T>) {\n    const [mutate, state] = useMutation(mutation, config, environment);\n    return children(mutate, state) as React.ReactElement;\n}\n","import { useEffect } from 'react';\nimport { GraphQLSubscriptionConfig, requestSubscription, OperationType } from 'relay-runtime';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\n    config: GraphQLSubscriptionConfig<TSubscriptionPayload>,\n): void {\n    const environment = useRelayEnvironment();\n\n    useEffect(() => {\n        const { dispose } = requestSubscription(environment, config);\n        return dispose;\n    }, [environment, config]);\n}\n","import { useMemo } from 'react';\nimport { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport {\n    PaginationFunction,\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n} from './RelayHooksType';\nimport { useOssFragment } from './useOssFragment';\n\nexport function usePagination<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [\n    $Call<KeyReturnType<TKey>>,\n    PaginationFunction<$Call<KeyReturnType<TKey>>, TOperationType['variables']>,\n];\nexport function usePagination<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [\n    $Call<KeyReturnType<TKey>> | null,\n    PaginationFunction<$Call<KeyReturnType<TKey>> | null, TOperationType['variables']>,\n];\nexport function usePagination<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>,\n    PaginationFunction<ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>, TOperationType['variables']>,\n];\nexport function usePagination<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null,\n    PaginationFunction<\n        ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null,\n        TOperationType['variables']\n    >,\n] {\n    const [data, resolver] = useOssFragment(fragmentNode, fragmentRef);\n\n    const fns = useMemo(() => {\n        return {\n            loadMore: resolver.loadMore,\n            hasMore: resolver.hasMore,\n            isLoading: resolver.isLoading,\n            refetchConnection: resolver.refetchConnection,\n        };\n    }, [resolver]);\n\n    return [data, fns];\n}\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport {\n    RefetchFunction,\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n} from './RelayHooksType';\nimport { useOssFragment } from './useOssFragment';\n\nexport function useRefetch<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [$Call<KeyReturnType<TKey>>, RefetchFunction<TOperationType['variables']>];\nexport function useRefetch<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [$Call<KeyReturnType<TKey>> | null, RefetchFunction<TOperationType['variables']>];\nexport function useRefetch<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>, RefetchFunction<TOperationType['variables']>];\nexport function useRefetch<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null,\n    RefetchFunction<TOperationType['variables']>,\n] {\n    const [data, { refetch }] = useOssFragment(fragmentNode, fragmentRef);\n\n    return [data, refetch];\n}\n","import * as invariant from 'fbjs/lib/invariant';\nimport { useCallback, useMemo } from 'react';\nimport { GraphQLTaggedNode, getFragment, OperationType, ConcreteRequest } from 'relay-runtime';\nimport {\n    RefetchableFunction,\n    RefetchOptions,\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n    ObserverOrCallback,\n} from './RelayHooksType';\nimport { useRefetch } from './useRefetch';\n\nexport function useRefetchable<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [$Call<KeyReturnType<TKey>>, RefetchableFunction<TOperationType['variables']>];\nexport function useRefetchable<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [$Call<KeyReturnType<TKey>> | null, RefetchableFunction<TOperationType['variables']>];\nexport function useRefetchable<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>,\n    RefetchableFunction<TOperationType['variables']>,\n];\nexport function useRefetchable<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null,\n    RefetchableFunction<TOperationType['variables']>,\n] {\n    const [data, refetch] = useRefetch(fragmentInput, fragmentRef);\n\n    const refetchNode = useMemo(() => {\n        const fragmentNode = getFragment(fragmentInput);\n        const metadata = fragmentNode.metadata;\n        invariant(\n            metadata != null,\n            'useRefetchable: Expected fragment `%s` to be refetchable when using `%s`. ' +\n                'Did you forget to add a @refetchable directive to the fragment?',\n            'useRefetchable',\n            fragmentNode.name,\n        );\n        const isPlural = metadata.plural;\n        invariant(\n            isPlural !== true,\n            'useRefetchable: Expected fragment `%s` not to be plural when using ' +\n                '`%s`. Remove `@relay(plural: true)` from fragment `%s` ' +\n                'in order to use it with `%s`.',\n            fragmentNode.name,\n            'useRefetchable',\n            fragmentNode.name,\n            'useRefetchable',\n        );\n\n        const refetchMetadata = metadata.refetch;\n        invariant(\n            refetchMetadata != null,\n            'useRefetchable: Expected fragment `%s` to be refetchable when using `%s`. ' +\n                'Did you forget to add a @refetchable directive to the fragment?',\n            'useRefetchable',\n            fragmentNode.name,\n        );\n\n        // handle both commonjs and es modules\n        const refetchableRequest: ConcreteRequest = (refetchMetadata as any).operation.default\n            ? (refetchMetadata as any).operation.default\n            : refetchMetadata.operation;\n\n        return refetchableRequest;\n    }, [fragmentInput]);\n\n    const refetchable = useCallback(\n        (\n            refetchVariables:\n                | TOperationType['variables']\n                | ((fragmentVariables: TOperationType['variables']) => TOperationType['variables']),\n            options: {\n                renderVariables?: TOperationType['variables'];\n                observerOrCallback?: ObserverOrCallback;\n                refetchOptions?: RefetchOptions;\n            } = {},\n        ) => {\n            return refetch(\n                refetchNode,\n                refetchVariables,\n                options.renderVariables,\n                options.observerOrCallback,\n                options.refetchOptions,\n            );\n        },\n        [refetch, refetchNode],\n    );\n\n    return [data, refetchable];\n}\n","import * as React from 'react';\nimport { Environment } from 'relay-runtime';\nimport { ReactRelayContext } from './ReactRelayContext'; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nexport const RelayEnvironmentProvider = function<\n    TEnvironment extends Environment = Environment\n>(props: { children: React.ReactNode; environment: TEnvironment }): JSX.Element {\n    const context = React.useMemo(() => ({ environment: props.environment }), [props.environment]);\n    return (\n        <ReactRelayContext.Provider value={context}>{props.children}</ReactRelayContext.Provider>\n    );\n};\n"],"names":["ReactRelayContext","createRelayContext","React","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","NETWORK_ONLY","STORE_THEN_NETWORK","STORE_OR_NETWORK","STORE_ONLY","FORWARD","isNetworkPolicy","policy","storeSnapshot","isStorePolicy","createOperation","gqlQuery","variables","createOperationDescriptor","getRequest","toObserver","observerOrCallback","error","complete","unsubscribe","subscription","getPaginationData","paginationData","fragment","metadata","foundConnectionMetadata","isRelayModern","connectionMetadata","connection","undefined","invariant","name","fragmentName","findConnectionMetadata","getConnectionFromProps","path","props","data","createGetConnectionFromProps","direction","getFragmentVariables","countVariable","count","prevVars","totalCount","createGetFragmentVariables","getNewSelector","request","areEqual","requestDescriptor","createRequestDescriptor","createReaderSelector","node","dataID","_getConnectionData","_a","connectionConfig","connectionData","_b","EDGES","PAGE_INFO","HAS_NEXT_PAGE","HAS_PREV_PAGE","END_CURSOR","START_CURSOR","edges","pageInfo","Array","isArray","hasMore","cursor","warning","edgeCount","fetchQuery","cache","Map","getOrCreateQueryFetcher","query","forceUpdate","suspense","queryFetcher","has","identifier","get","QueryFetcher","setForceUpdate","useLazy","disposeRequest","disposeRetain","clearTemporaryRetain","disposableRetain","dispose","delete","clearTimeout","releaseQueryTimeout","setTimeout","_this","environment","operation","fetchPolicy","check","status","lookup","options","retain","networkCacheConfig","fetchKey","fetchObserver","retry","cacheConfigOverride","observer","fetch","cached","isDiffEnvQuery","set","lookupInStore","snapshot","subscribe","resultSnapshot","rootSubscription","fetchHasReturned","resolveNetworkPromise","force","start","networkSubscription","next","_onQueryDataAvailable","notifyFirstResult","temporaryRetain","Promise","resolve","useQueryFetcher","ref","useRef","current","useEffect","useRelayEnvironment","useMemoOperationDescriptor","value","latestValue","memoVariables","useMemo","useQuery","execute","useLazyLoadQuery","internalLoadQuery","promise","queryExecute","listener","prev","result","e","then","callback","getValue","isPromise","loadLazyQuery","loadQuery","usePreloadedQuery","getFragmentResult","map","taggedNode","refetchVariables","renderVariables","fragmentVariables","fetchVariables","newFragmentVariables","executeFetcher","payload","changeVariables","refreshHooks","_refetchSubscription","_fragment","getData","_refetchVariables","_fetchPage","pageSize","Observable","create","sink","refetchConnection","_forceUpdate","FragmentResolver","indexUpdate","_disposable","disposeSelectionReferences","_isARequestInFlight","_disposeCacheSelectionReference","_selectionReferences","forEach","r","_cacheSelectionReference","_environment","fRef","_fragmentRef","getVariablesFromFragment","fragmentRef","prevIDs","getDataIDsFromFragment","nextIDs","fragmentNode","_fragmentNode","getFragment","changedFragmentRef","_result","_isPlural","plural","_selector","getSelector","selector","kind","selectors","renderedSnapshot","dataSubscriptions","idx","push","latestSnapshot","_retainCachedOperation","paginatingVariables","rootVariables","owner","getVariables","prevData","thisArg","P","generator","nextData","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","TypeError","done","pop","step","reject","fulfilled","rejected","onNext","cacheConfig","refetchSubscription","isNetwork","reference_1","fetchQueryOptions","cleanup","concat","mergeMap","do","useOssFragment","resolver","useFragment","useCallback","useState","useMutation","mutation","userConfig","state","setState","isMounted","useMounted","relayEnvironment","resolvedEnvironment","configs","uploadables","onCompleted","onError","optimisticUpdater","optimisticResponse","updater","config","mergedConfig","loading","handleError","commitMutation","response","errors","useSubscription","usePagination","loadMore","isLoading","useRefetch","useRefetchable","fragmentInput","refetch","refetchNode","refetchMetadata","default","refetchOptions","RelayEnvironmentProvider","context","Provider","children"],"mappings":"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"}
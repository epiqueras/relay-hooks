{"version":3,"file":"cjs-relay-hooks.min.js","sources":["../src/ReactRelayContext.ts","../node_modules/tslib/tslib.es6.js","../src/Utils.ts","../src/RelayHooksType.ts","../src/QueryFetcher.ts","../src/useQueryFetcher.ts","../src/useRelayEnvironment.ts","../src/useQuery.ts","../src/loadQuery.ts","../src/FragmentResolver.ts","../src/useOssFragment.tsx","../src/useMutation.ts","../src/useRefetch.ts","../src/RelayEnvironmentProvider.tsx","../src/useFragment.tsx","../src/useLazyLoadQuery.ts","../src/usePagination.ts","../src/usePreloadedQuery.ts","../src/useRefetchable.ts","../src/useSubscription.ts"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport * as React from 'react';\nimport { __internal } from 'relay-runtime';\n\nconst { createRelayContext } = __internal as any;\n\nexport const ReactRelayContext = createRelayContext(React);\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as warning from 'fbjs/lib/warning';\nimport {\n    Observer,\n    Variables,\n    ConnectionMetadata,\n    ConnectionInterface,\n    createRequestDescriptor,\n    createReaderSelector,\n    createOperationDescriptor,\n    getRequest,\n    GraphQLTaggedNode,\n    OperationDescriptor,\n    SingularReaderSelector,\n} from 'relay-runtime';\nimport {\n    STORE_OR_NETWORK,\n    STORE_THEN_NETWORK,\n    NETWORK_ONLY,\n    FetchPolicy,\n    FragmentVariablesGetter,\n    FORWARD,\n    PaginationData,\n    ConnectionConfig,\n    ObserverOrCallback,\n} from './RelayHooksType';\n\nexport type ReactConnectionMetadata = ConnectionMetadata & { fragmentName: string };\n\nexport const isNetworkPolicy = (policy: FetchPolicy, storeSnapshot): boolean => {\n    return (\n        policy === NETWORK_ONLY ||\n        policy === STORE_THEN_NETWORK ||\n        (policy === STORE_OR_NETWORK && !storeSnapshot)\n    );\n};\n\nexport const isStorePolicy = (policy: FetchPolicy): boolean => {\n    return policy !== NETWORK_ONLY;\n};\n\n// Fetcher\nexport function createOperation(\n    gqlQuery: GraphQLTaggedNode,\n    variables: Variables,\n): OperationDescriptor {\n    return createOperationDescriptor(getRequest(gqlQuery), variables);\n}\n\n// pagination utils\n\nexport function findConnectionMetadata(fragment): ReactConnectionMetadata {\n    let foundConnectionMetadata = null;\n    let isRelayModern = false;\n    // for (const fragmentName in fragments) {\n    //   const fragment = fragments[fragmentName];\n    const connectionMetadata: Array<ConnectionMetadata> =\n        fragment.metadata && (fragment.metadata.connection as any);\n    // HACK: metadata is always set to `undefined` in classic. In modern, even\n    // if empty, it is set to null (never undefined). We use that knowlege to\n    // check if we're dealing with classic or modern\n    if (fragment.metadata !== undefined) {\n        isRelayModern = true;\n    }\n    if (connectionMetadata) {\n        invariant(\n            connectionMetadata.length === 1,\n            'ReactRelayPaginationContainer: Only a single @connection is ' +\n                'supported, `%s` has %s.',\n            fragment.name,\n            connectionMetadata.length,\n        );\n        invariant(\n            !foundConnectionMetadata,\n            'ReactRelayPaginationContainer: Only a single fragment with ' +\n                '@connection is supported.',\n        );\n        foundConnectionMetadata = {\n            ...connectionMetadata[0],\n            fragmentName: fragment.name,\n        };\n    }\n    //}\n    invariant(\n        !isRelayModern || foundConnectionMetadata !== null,\n        'ReactRelayPaginationContainer: A @connection directive must be present.',\n    );\n    return foundConnectionMetadata || ({} as any);\n}\n\nexport function createGetConnectionFromProps(metadata: ReactConnectionMetadata): any {\n    const path = metadata.path;\n    invariant(\n        path,\n        'ReactRelayPaginationContainer: Unable to synthesize a ' +\n            'getConnectionFromProps function.',\n    );\n    return (props): any => {\n        let data = props;\n        for (let i = 0; i < path.length; i++) {\n            if (!data || typeof data !== 'object') {\n                return null;\n            }\n            data = data[path[i]];\n        }\n        return data;\n    };\n}\n\nexport function createGetFragmentVariables(\n    metadata: ReactConnectionMetadata,\n): FragmentVariablesGetter {\n    const countVariable = metadata.count;\n    invariant(\n        countVariable,\n        'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getFragmentVariables function.',\n    );\n    return (prevVars: Variables, totalCount: number): Variables => ({\n        ...prevVars,\n        [countVariable]: totalCount,\n    });\n}\n\n/*eslint-disable */\nexport function toObserver(observerOrCallback: ObserverOrCallback): Observer<void> {\n    return typeof observerOrCallback === 'function'\n        ? {\n              error: observerOrCallback,\n              complete: observerOrCallback,\n              unsubscribe: (subscription): void => {\n                  typeof observerOrCallback === 'function' && observerOrCallback();\n              },\n          }\n        : observerOrCallback || ({} as any);\n}\n/*eslint-enable */\nexport function getPaginationData(paginationData, fragment): PaginationData {\n    if (!paginationData) {\n        const metadata = findConnectionMetadata(fragment);\n        const getConnectionFromProps = createGetConnectionFromProps(metadata);\n        const direction = metadata.direction;\n        invariant(\n            direction,\n            'ReactRelayPaginationContainer: Unable to infer direction of the ' +\n                'connection, possibly because both first and last are provided.',\n        );\n\n        const getFragmentVariables = createGetFragmentVariables(metadata);\n\n        return {\n            direction,\n            getConnectionFromProps,\n            getFragmentVariables,\n        };\n    }\n    return paginationData;\n}\n\nexport function getNewSelector(request, s, variables): SingularReaderSelector {\n    if (areEqual(variables, s.variables)) {\n        // If we're not actually setting new variables, we don't actually want\n        // to create a new fragment owner, since areEqualSelectors relies on\n        // owner identity.\n        // In fact, we don't even need to try to attempt to set a new selector.\n        // When fragment ownership is not enabled, setSelector will also bail\n        // out since the selector doesn't really change, so we're doing it here\n        // earlier.\n        return s;\n    }\n    // NOTE: We manually create the request descriptor here instead of\n    // calling createOperationDescriptor() because we want to set a\n    // descriptor with *unaltered* variables as the fragment owner.\n    // This is a hack that allows us to preserve exisiting (broken)\n    // behavior of RelayModern containers while using fragment ownership\n    // to propagate variables instead of Context.\n    // For more details, see the summary of D13999308\n    const requestDescriptor = createRequestDescriptor(request, variables);\n    const selector = createReaderSelector(s.node, s.dataID, variables, requestDescriptor);\n    return selector;\n}\n\nexport function _getConnectionData(\n    { direction, getConnectionFromProps: defaultGetConnectionFromProps }: PaginationData,\n    props: any,\n    connectionConfig?: ConnectionConfig,\n): {\n    cursor: string;\n    edgeCount: number;\n    hasMore: boolean;\n} {\n    // Extract connection data and verify there are more edges to fetch\n    const getConnectionFromProps =\n        connectionConfig && connectionConfig.getConnectionFromProps\n            ? connectionConfig.getConnectionFromProps\n            : defaultGetConnectionFromProps; // todo\n    const connectionData = getConnectionFromProps(props);\n    if (connectionData == null) {\n        return null;\n    }\n    const {\n        EDGES,\n        PAGE_INFO,\n        HAS_NEXT_PAGE,\n        HAS_PREV_PAGE,\n        END_CURSOR,\n        START_CURSOR,\n    } = ConnectionInterface.get();\n\n    invariant(\n        typeof connectionData === 'object',\n        'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' +\n            'to return `null` or a plain object with %s and %s properties, got `%s`.',\n        'useFragment pagination',\n        EDGES,\n        PAGE_INFO,\n        connectionData,\n    );\n    const edges = connectionData[EDGES];\n    const pageInfo = connectionData[PAGE_INFO];\n    if (edges == null || pageInfo == null) {\n        return null;\n    }\n    invariant(\n        Array.isArray(edges),\n        'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' +\n            'to return an object with %s: Array, got `%s`.',\n        'useFragment pagination',\n        EDGES,\n        edges,\n    );\n    invariant(\n        typeof pageInfo === 'object',\n        'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' +\n            'to return an object with %s: Object, got `%s`.',\n        'useFragment pagination',\n        PAGE_INFO,\n        pageInfo,\n    );\n    const hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];\n    const cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];\n    if (typeof hasMore !== 'boolean' || (edges.length !== 0 && typeof cursor === 'undefined')) {\n        warning(\n            false,\n            'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' +\n                'Be sure to fetch %s (got `%s`) and %s (got `%s`).',\n            PAGE_INFO,\n            'useFragment pagination',\n            direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE,\n            hasMore,\n            direction === FORWARD ? END_CURSOR : START_CURSOR,\n            cursor,\n        );\n        return null;\n    }\n    return {\n        cursor,\n        edgeCount: edges.length,\n        hasMore,\n    };\n}\n\n/*eslint-disable */\nexport function getRootVariablesForSelector(selector): Variables {\n    return selector != null && selector.kind === 'PluralReaderSelector'\n        ? selector.selectors[0]\n            ? selector.selectors[0].owner.variables\n            : {}\n        : selector\n        ? selector.owner.variables\n        : {};\n}\n","import {\n    Disposable,\n    OperationType,\n    CacheConfig,\n    GraphQLTaggedNode,\n    Environment,\n    IEnvironment,\n    Variables,\n    PageInfo,\n    Observer,\n    MutationConfig as BaseMutationConfig,\n    MutationParameters,\n} from 'relay-runtime';\nimport {\n    RelayContext,\n    FragmentSpecResolver,\n    Snapshot,\n} from 'relay-runtime/lib/store/RelayStoreTypes';\n\nexport type MutationState<T extends MutationParameters> = {\n    loading: boolean;\n    data: T['response'] | null;\n    error?: Error | null;\n};\n\nexport type MutationNode<T extends MutationParameters> = BaseMutationConfig<T>['mutation'];\n\nexport type MutationConfig<T extends MutationParameters> = Partial<\n    Omit<BaseMutationConfig<T>, 'mutation' | 'onCompleted'>\n> & {\n    onCompleted?(response: T['response']): void;\n};\n\nexport type Mutate<T extends MutationParameters> = (\n    config?: Partial<MutationConfig<T>>,\n) => Promise<T['response']>;\n\nexport type MutationProps<T extends MutationParameters> = MutationConfig<T> & {\n    children: (mutate: Mutate<T>, state: MutationState<T>) => React.ReactNode;\n    mutation: MutationNode<T>;\n    /** if not provided, the context environment will be used. */\n    environment?: Environment;\n};\n\nexport const NETWORK_ONLY = 'network-only';\nexport const STORE_THEN_NETWORK = 'store-and-network';\nexport const STORE_OR_NETWORK = 'store-or-network';\nexport const STORE_ONLY = 'store-only';\n\nexport type FetchPolicy =\n    | typeof STORE_ONLY\n    | typeof STORE_OR_NETWORK\n    | typeof STORE_THEN_NETWORK\n    | typeof NETWORK_ONLY;\n\nexport type ContainerResult = {\n    data: { [key: string]: any };\n    resolver: FragmentSpecResolver;\n};\n\nexport interface RenderProps<T extends OperationType> {\n    error: Error | null;\n    props: T['response'] | null | undefined;\n    retry: (_cacheConfigOverride?: CacheConfig, observer?: Observer<Snapshot>) => void;\n    cached?: boolean;\n}\n\nexport type OperationContextProps = {\n    operation: any;\n    relay: RelayContext;\n};\n\nexport type RefetchOptions = {\n    force?: boolean;\n    fetchPolicy?: FetchPolicy;\n    metadata?: { [key: string]: any };\n};\n\nexport type QueryOptions = {\n    fetchPolicy?: FetchPolicy;\n    fetchKey?: string | number;\n    networkCacheConfig?: CacheConfig;\n    skip?: boolean;\n    fetchObserver?: Observer<Snapshot>;\n};\n\nexport type $Call<Fn extends (...args: any[]) => any> = Fn extends (arg: any) => infer RT\n    ? RT\n    : never;\n\nexport interface KeyType {\n    readonly ' $data'?: unknown;\n}\nexport type ArrayKeyType = ReadonlyArray<{ readonly ' $data'?: ReadonlyArray<unknown> } | null>;\n\nexport type KeyReturnType<T extends KeyType> = (arg: T) => NonNullable<T[' $data']>;\nexport type ArrayKeyReturnType<T extends ArrayKeyType> = (\n    arg: T,\n) => NonNullable<NonNullable<T[0]>[' $data']>[0];\n\nexport type PaginationFunction<Props, TVariables extends Variables = Variables> = {\n    loadMore: (\n        connectionConfig: ConnectionConfig<Props>,\n        pageSize: number,\n        observerOrCallback?: ObserverOrCallback,\n        options?: RefetchOptions,\n    ) => Disposable;\n    hasMore: (connectionConfig?: ConnectionConfig<Props>) => boolean;\n    isLoading: () => boolean;\n    refetchConnection: (\n        connectionConfig: ConnectionConfig<Props>,\n        totalCount: number,\n        observerOrCallback?: ObserverOrCallback,\n        refetchVariables?: TVariables,\n    ) => Disposable;\n};\n\nexport type RefetchableFunction<TVariables extends Variables = Variables> = (\n    refetchVariables: TVariables | ((fragmentVariables: TVariables) => TVariables),\n    options?: {\n        renderVariables?: TVariables;\n        observerOrCallback?: ObserverOrCallback;\n        refetchOptions?: RefetchOptions;\n    },\n) => Disposable;\n\nexport type RefetchFunction<TVariables extends Variables = Variables> = (\n    taggedNode: GraphQLTaggedNode,\n    refetchVariables: TVariables | ((fragmentVariables: TVariables) => TVariables),\n    renderVariables?: TVariables,\n    observerOrCallback?: ObserverOrCallback,\n    options?: RefetchOptions,\n) => Disposable;\n\nexport type ObserverOrCallback = Observer<void> | ((error?: Error | null | undefined) => void);\n\n// pagination\n\nexport const FORWARD = 'forward';\n\nexport type FragmentVariablesGetter = (prevVars: Variables, totalCount: number) => Variables;\n\nexport interface ConnectionConfig<Props = object> {\n    direction?: 'backward' | 'forward';\n    getConnectionFromProps?: (props: Props) => ConnectionData | null | undefined;\n    getFragmentVariables?: (prevVars: Variables, totalCount: number) => Variables;\n    getVariables: (\n        props: Props,\n        paginationInfo: { count: number; cursor?: string | null },\n        fragmentVariables: Variables,\n    ) => Variables;\n    query: GraphQLTaggedNode;\n}\nexport interface ConnectionData {\n    edges?: ReadonlyArray<any> | null;\n    pageInfo?: Partial<PageInfo> | null;\n}\n\nexport type PaginationData = {\n    direction: string;\n    getConnectionFromProps: Function;\n    getFragmentVariables: Function;\n};\n\nexport type LoadQuery<\n    TOperationType extends OperationType = OperationType,\n    TEnvironment extends IEnvironment = IEnvironment\n> = {\n    next: (\n        environment: TEnvironment,\n        gqlQuery: GraphQLTaggedNode,\n        variables?: TOperationType['variables'],\n        options?: QueryOptions,\n    ) => Promise<void>;\n    subscribe: (callback: (value: any) => any) => () => void;\n    getValue: (environment?: TEnvironment) => RenderProps<TOperationType> | Promise<any>;\n    dispose: () => void;\n};\n","import {\n    Disposable,\n    CacheConfig,\n    IEnvironment,\n    Snapshot,\n    __internal,\n    OperationType,\n    OperationDescriptor,\n    Observer,\n} from 'relay-runtime';\nimport { FetchPolicy, RenderProps, QueryOptions } from './RelayHooksType';\nimport { isNetworkPolicy, isStorePolicy } from './Utils';\n\nconst { fetchQuery } = __internal;\n\nconst defaultPolicy = 'store-or-network';\n\nconst cache: Map<string, QueryFetcher<any>> = new Map();\n\nexport function getOrCreateQueryFetcher<TOperationType extends OperationType>(\n    query: OperationDescriptor | null,\n    forceUpdate: any,\n): QueryFetcher<TOperationType> {\n    const suspense = !!query;\n    const queryFetcher =\n        suspense && cache.has(query.request.identifier)\n            ? cache.get(query.request.identifier)\n            : new QueryFetcher(suspense, suspense);\n    queryFetcher.setForceUpdate(forceUpdate);\n    return queryFetcher;\n}\n\nconst DATA_RETENTION_TIMEOUT = 30 * 1000;\n\nexport class QueryFetcher<TOperationType extends OperationType = OperationType> {\n    environment: IEnvironment;\n    query: OperationDescriptor;\n    networkSubscription: Disposable;\n    rootSubscription: Disposable;\n    error: Error | null;\n    snapshot: Snapshot;\n    fetchPolicy: FetchPolicy;\n    fetchKey: string | number;\n    disposableRetain: Disposable;\n    forceUpdate: (_o: any) => void;\n    suspense: boolean;\n    useLazy: boolean;\n    releaseQueryTimeout;\n\n    constructor(suspense = false, useLazy = false) {\n        this.suspense = suspense;\n        this.useLazy = suspense && useLazy;\n        this.setForceUpdate(() => undefined);\n    }\n\n    setForceUpdate(forceUpdate): void {\n        this.forceUpdate = forceUpdate;\n    }\n\n    dispose(): void {\n        this.disposeRequest();\n        this.disposeRetain();\n    }\n\n    disposeRetain(): void {\n        this.clearTemporaryRetain();\n        this.disposableRetain && this.disposableRetain.dispose();\n        this.query && cache.delete(this.query.request.identifier);\n    }\n\n    clearTemporaryRetain(): void {\n        clearTimeout(this.releaseQueryTimeout);\n        this.releaseQueryTimeout = null;\n    }\n\n    temporaryRetain(): void {\n        const localReleaseTemporaryRetain = (): void => {\n            this.dispose();\n        };\n        this.releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT);\n    }\n\n    isDiffEnvQuery(environment: IEnvironment, query): boolean {\n        return (\n            environment !== this.environment ||\n            query.request.identifier !== this.query.request.identifier\n        );\n    }\n\n    lookupInStore(environment: IEnvironment, operation, fetchPolicy: FetchPolicy): Snapshot {\n        if (isStorePolicy(fetchPolicy)) {\n            const check: any = environment.check(operation);\n            if (check === 'available' || check.status === 'available') {\n                return environment.lookup(operation.fragment);\n            }\n        }\n        return null;\n    }\n\n    execute(\n        environment: IEnvironment,\n        query: OperationDescriptor,\n        options: QueryOptions,\n        retain: (environment, query) => Disposable = (environment, query): Disposable =>\n            environment.retain(query),\n    ): RenderProps<TOperationType> {\n        const {\n            fetchPolicy = defaultPolicy,\n            networkCacheConfig,\n            fetchKey,\n            skip,\n            fetchObserver,\n        } = options;\n        let storeSnapshot;\n        const retry = (\n            cacheConfigOverride: CacheConfig = networkCacheConfig,\n            observer?: Observer<Snapshot>,\n        ): void => {\n            this.disposeRequest();\n            this.fetch(cacheConfigOverride, false, observer);\n        };\n        if (skip) {\n            return {\n                cached: false,\n                retry,\n                error: null,\n                props: undefined,\n            };\n        }\n        this.clearTemporaryRetain();\n        const isDiffEnvQuery = this.isDiffEnvQuery(environment, query);\n        if (isDiffEnvQuery || fetchPolicy !== this.fetchPolicy || fetchKey !== this.fetchKey) {\n            if (isDiffEnvQuery) {\n                this.disposeRetain();\n                this.useLazy && cache.set(query.request.identifier, this);\n                this.disposableRetain = retain(environment, query);\n            }\n            this.environment = environment;\n            this.query = query;\n            this.fetchPolicy = fetchPolicy;\n            this.fetchKey = fetchKey;\n            this.disposeRequest();\n\n            storeSnapshot = this.lookupInStore(environment, this.query, fetchPolicy);\n            const isNetwork = isNetworkPolicy(fetchPolicy, storeSnapshot);\n            if (isNetwork) {\n                this.fetch(networkCacheConfig, this.suspense && !storeSnapshot, fetchObserver);\n            } else if (!!storeSnapshot) {\n                this.snapshot = storeSnapshot;\n                this.error = null;\n                this.subscribe(storeSnapshot);\n            }\n        }\n\n        const resultSnapshot = storeSnapshot || this.snapshot;\n        return {\n            cached: !!storeSnapshot,\n            retry,\n            error: this.error,\n            props: resultSnapshot ? resultSnapshot.data : null,\n        };\n    }\n\n    subscribe(snapshot): void {\n        if (this.rootSubscription) {\n            this.rootSubscription.dispose();\n        }\n        this.rootSubscription = this.environment.subscribe(snapshot, (snapshot) => {\n            // Read from this._fetchOptions in case onDataChange() was lazily added.\n            this.snapshot = snapshot;\n            this.error = null;\n            this.forceUpdate(snapshot);\n        });\n    }\n\n    fetch(networkCacheConfig, suspense: boolean, observer = {} as Observer<Snapshot>): void {\n        let fetchHasReturned = false;\n        let resolveNetworkPromise = (): void => {};\n        fetchQuery(this.environment, this.query, {\n            networkCacheConfig:\n                suspense && !networkCacheConfig ? { force: true } : networkCacheConfig,\n        }).subscribe({\n            start: (subscription) => {\n                this.networkSubscription = {\n                    dispose: (): void => subscription.unsubscribe(),\n                };\n                observer.start && observer.start(subscription);\n            },\n            next: () => {\n                this.error = null;\n                this._onQueryDataAvailable({\n                    notifyFirstResult: fetchHasReturned,\n                    suspense,\n                    observer,\n                });\n                resolveNetworkPromise();\n            },\n            error: (error) => {\n                this.error = error;\n                this.snapshot = null;\n                if (fetchHasReturned && !suspense) {\n                    this.forceUpdate(error);\n                }\n                resolveNetworkPromise();\n                this.networkSubscription = null;\n                observer.error && observer.error(error);\n            },\n            complete: () => {\n                this.networkSubscription = null;\n                observer.complete && observer.complete();\n            },\n            unsubscribe: (subscription) => {\n                if (this.useLazy && !this.rootSubscription && this.releaseQueryTimeout) {\n                    this.dispose();\n                }\n                observer.unsubscribe && observer.unsubscribe(subscription);\n            },\n        });\n        fetchHasReturned = true;\n        if (suspense) {\n            if (this.useLazy) {\n                this.setForceUpdate(() => undefined);\n                this.temporaryRetain();\n            }\n            throw new Promise((resolve) => {\n                resolveNetworkPromise = resolve;\n            });\n        }\n    }\n\n    disposeRequest(): void {\n        this.error = null;\n        this.snapshot = null;\n        if (this.networkSubscription) {\n            this.networkSubscription.dispose();\n            this.networkSubscription = null;\n        }\n        if (this.rootSubscription) {\n            this.rootSubscription.dispose();\n            this.rootSubscription = null;\n        }\n    }\n\n    _onQueryDataAvailable({\n        notifyFirstResult,\n        suspense,\n        observer,\n    }: {\n        notifyFirstResult: boolean;\n        suspense: boolean;\n        observer: Observer<Snapshot>;\n    }): void {\n        // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n        // multiple times by network layers that support data subscriptions.\n        // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n\n        if (this.snapshot) {\n            return;\n        }\n\n        this.snapshot = this.environment.lookup(this.query.fragment);\n\n        // Subscribe to changes in the data of the root fragment\n        this.subscribe(this.snapshot);\n\n        observer.next && observer.next(this.snapshot);\n\n        if (this.snapshot && notifyFirstResult && !suspense) {\n            this.forceUpdate(this.snapshot);\n        }\n    }\n}\n","import { useState, useEffect, useRef } from 'react';\nimport { OperationType, OperationDescriptor } from 'relay-runtime';\nimport { QueryFetcher, getOrCreateQueryFetcher } from './QueryFetcher';\n\nexport type Reference<TOperationType extends OperationType = OperationType> = {\n    queryFetcher: QueryFetcher<TOperationType>;\n};\n\n// set query when you want suspends\nexport const useQueryFetcher = <TOperationType extends OperationType>(\n    query?: OperationDescriptor,\n): QueryFetcher<TOperationType> => {\n    const [, forceUpdate] = useState(null);\n    const ref = useRef<Reference<TOperationType>>();\n    if (ref.current === null || ref.current === undefined) {\n        ref.current = {\n            queryFetcher: getOrCreateQueryFetcher(query, forceUpdate),\n        };\n    }\n    //const { queryFetcher } = ref.current;\n\n    useEffect(() => {\n        return (): void => ref.current.queryFetcher.dispose();\n    }, []);\n    return ref.current.queryFetcher;\n};\n","import * as React from 'react';\nimport { IEnvironment } from 'relay-runtime';\nimport { ReactRelayContext } from './ReactRelayContext';\n\nexport function useRelayEnvironment<\n    TEnvironment extends IEnvironment = IEnvironment\n>(): TEnvironment {\n    const { environment } = React.useContext(ReactRelayContext);\n    return environment;\n}\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport { useRef, useMemo } from 'react';\nimport { GraphQLTaggedNode, OperationType, OperationDescriptor, Variables } from 'relay-runtime';\nimport { RenderProps, QueryOptions } from './RelayHooksType';\nimport { useQueryFetcher } from './useQueryFetcher';\nimport { useRelayEnvironment } from './useRelayEnvironment';\nimport { createOperation } from './Utils';\n\nexport function useDeepCompare<T>(value: T): T {\n    const latestValue = useRef(value);\n    if (!areEqual(latestValue.current, value)) {\n        latestValue.current = value;\n    }\n    return latestValue.current;\n}\n\nexport function useMemoOperationDescriptor(\n    gqlQuery: GraphQLTaggedNode,\n    variables: Variables,\n): OperationDescriptor {\n    const memoVariables = useDeepCompare(variables);\n    return useMemo(() => createOperation(gqlQuery, memoVariables), [gqlQuery, memoVariables]);\n}\n\nexport const useQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'] = {},\n    options: QueryOptions = {},\n): RenderProps<TOperationType> => {\n    const environment = useRelayEnvironment();\n    const query = useMemoOperationDescriptor(gqlQuery, variables);\n    const queryFetcher = useQueryFetcher<TOperationType>();\n\n    return queryFetcher.execute(environment, query, options);\n};\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport {\n    GraphQLTaggedNode,\n    OperationType,\n    IEnvironment,\n    isPromise,\n    OperationDescriptor,\n    Disposable,\n} from 'relay-runtime';\nimport { QueryFetcher } from './QueryFetcher';\nimport { RenderProps, QueryOptions, LoadQuery } from './RelayHooksType';\nimport { createOperation } from './Utils';\n\nexport const internalLoadQuery = <TOperationType extends OperationType = OperationType>(\n    promise = false,\n    queryExecute = (\n        queryFetcher: QueryFetcher<TOperationType>,\n        environment: IEnvironment,\n        query: OperationDescriptor,\n        options: QueryOptions,\n        retain?: (environment, query) => Disposable,\n    ): RenderProps<TOperationType> => queryFetcher.execute(environment, query, options, retain),\n): LoadQuery<TOperationType> => {\n    let data: RenderProps<TOperationType> | null | Promise<any> = null;\n    let listener = undefined;\n    let queryFetcher = new QueryFetcher<TOperationType>(true);\n\n    let prev = {\n        environment: null,\n        gqlQuery: null,\n        variables: null,\n        options: null,\n        query: null,\n    };\n\n    const dispose = (): void => {\n        queryFetcher.dispose();\n        queryFetcher = new QueryFetcher<TOperationType>(true);\n        listener = undefined;\n        data = null;\n        prev = {\n            environment: null,\n            gqlQuery: null,\n            variables: null,\n            options: null,\n            query: null,\n        };\n    };\n\n    const next = (\n        environment,\n        gqlQuery: GraphQLTaggedNode,\n        variables: TOperationType['variables'] = {},\n        options: QueryOptions = {},\n    ): Promise<void> => {\n        prev.environment = environment;\n        prev.options = options;\n        if (!areEqual(variables, prev.variables) || gqlQuery != prev.gqlQuery) {\n            prev.variables = variables;\n            prev.gqlQuery = gqlQuery;\n            prev.query = createOperation(gqlQuery, prev.variables);\n        }\n        const execute = (): void => {\n            data = queryExecute(queryFetcher, prev.environment, prev.query, prev.options);\n            listener && listener(data);\n        };\n\n        queryFetcher.setForceUpdate(execute);\n        let result;\n        try {\n            execute();\n        } catch (e) {\n            result = e.then(execute);\n            if (promise) {\n                data = result;\n            } else {\n                execute();\n            }\n        }\n        return result ?? Promise.resolve();\n    };\n\n    const getValue = (\n        environment?: IEnvironment,\n    ): RenderProps<TOperationType> | null | Promise<any> => {\n        if (environment && environment != prev.environment) {\n            next(environment, prev.gqlQuery, prev.variables, prev.options);\n        }\n        if (isPromise(data)) {\n            throw data;\n        }\n\n        return data;\n    };\n\n    const subscribe = (callback: (value) => any): (() => void) => {\n        listener = callback;\n        return (): void => {\n            if (listener === callback) {\n                listener = null;\n            }\n        };\n    };\n    return {\n        next,\n        subscribe,\n        getValue,\n        dispose,\n    };\n};\n\nexport const loadLazyQuery = <\n    TOperationType extends OperationType = OperationType\n>(): LoadQuery<TOperationType> => {\n    return internalLoadQuery(true);\n};\n\nexport const loadQuery = <\n    TOperationType extends OperationType = OperationType\n>(): LoadQuery<TOperationType> => {\n    return internalLoadQuery(false);\n};\n","import * as areEqual from 'fbjs/lib/areEqual';\nimport * as invariant from 'fbjs/lib/invariant';\nimport {\n    getSelector,\n    IEnvironment,\n    Disposable,\n    Snapshot,\n    getFragment,\n    Variables,\n    getVariablesFromFragment,\n    GraphQLTaggedNode,\n    Observable,\n    Observer,\n    OperationDescriptor,\n    CacheConfig,\n    Subscription,\n    getDataIDsFromFragment,\n    PluralReaderSelector,\n    __internal,\n    ReaderSelector,\n} from 'relay-runtime';\nimport {\n    RefetchOptions,\n    PaginationData,\n    ConnectionConfig,\n    ObserverOrCallback,\n} from './RelayHooksType';\nimport {\n    isNetworkPolicy,\n    isStorePolicy,\n    getPaginationData,\n    _getConnectionData,\n    toObserver,\n    getRootVariablesForSelector,\n    getNewSelector,\n    createOperation,\n} from './Utils';\n\nconst { fetchQuery } = __internal;\n\ntype SingularOrPluralSnapshot = Snapshot | Array<Snapshot>;\n\nfunction lookupFragment(environment, selector): SingularOrPluralSnapshot {\n    return selector.kind === 'PluralReaderSelector'\n        ? selector.selectors.map((s) => environment.lookup(s))\n        : environment.lookup(selector);\n}\n\nfunction getFragmentResult(snapshot: SingularOrPluralSnapshot): any {\n    if (Array.isArray(snapshot)) {\n        return { snapshot, data: snapshot.map((s) => s.data) };\n    }\n    return { snapshot, data: snapshot.data };\n}\n\ntype FragmentResult = {\n    snapshot: SingularOrPluralSnapshot | null;\n    data: any;\n};\n\nexport class FragmentResolver {\n    _environment: IEnvironment;\n    _fragment: any;\n    _fragmentNode: any;\n    _fragmentRef: any;\n    _result: FragmentResult;\n    _disposable: Disposable = { dispose: () => {} };\n    _selector: ReaderSelector;\n    _forceUpdate: any;\n    _isPlural: boolean;\n    _refetchSubscription: Subscription;\n    paginationData: PaginationData;\n    _refetchVariables: Variables;\n    _isARequestInFlight = false;\n    _selectionReferences: Array<Disposable> = [];\n    _cacheSelectionReference: Disposable;\n    indexUpdate = 0;\n\n    constructor(forceUpdate) {\n        this._forceUpdate = forceUpdate;\n    }\n\n    refreshHooks(): void {\n        this.indexUpdate += 1;\n        this._forceUpdate(this.indexUpdate);\n    }\n\n    dispose(): void {\n        this._disposable && this._disposable.dispose();\n        this._refetchSubscription && this._refetchSubscription.unsubscribe();\n        this._refetchSubscription = null;\n        this.disposeSelectionReferences();\n\n        this._isARequestInFlight = false;\n    }\n\n    disposeSelectionReferences(): void {\n        this._disposeCacheSelectionReference();\n        this._selectionReferences.forEach((r) => r.dispose());\n        this._selectionReferences = [];\n    }\n\n    _retainCachedOperation(operation: OperationDescriptor): void {\n        this._disposeCacheSelectionReference();\n        this._cacheSelectionReference = this._environment.retain(operation);\n    }\n\n    _disposeCacheSelectionReference(): void {\n        this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n        this._cacheSelectionReference = null;\n    }\n\n    getFragmentVariables(fRef = this._fragmentRef): Variables {\n        return getVariablesFromFragment(this._fragment, fRef);\n    }\n\n    changedFragmentRef(fragmentRef): boolean {\n        if (this._fragmentRef !== fragmentRef) {\n            const prevIDs = getDataIDsFromFragment(this._fragment, this._fragmentRef);\n            const nextIDs = getDataIDsFromFragment(this._fragment, fragmentRef);\n\n            if (\n                !areEqual(prevIDs, nextIDs) ||\n                !areEqual(\n                    this.getFragmentVariables(fragmentRef),\n                    this.getFragmentVariables(this._fragmentRef),\n                )\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    resolve(environment: IEnvironment, fragmentNode, fragmentRef): void {\n        if (this._fragmentNode !== fragmentNode) {\n            this._fragment = getFragment(fragmentNode);\n            this.paginationData = null;\n        }\n        if (\n            this._environment !== environment ||\n            this._fragmentNode !== fragmentNode ||\n            this.changedFragmentRef(fragmentRef)\n        ) {\n            this._environment = environment;\n            this._fragmentNode = fragmentNode;\n            this._fragmentRef = fragmentRef;\n            this._result = null;\n            this.dispose();\n            if (this._fragmentRef == null) {\n                this._result = { data: null, snapshot: null };\n            }\n\n            // If fragmentRef is plural, ensure that it is an array.\n            // If it's empty, return the empty array direclty before doing any more work.\n            this._isPlural =\n                this._fragment.metadata &&\n                this._fragment.metadata.plural &&\n                this._fragment.metadata.plural === true;\n            if (this._isPlural) {\n                if (this._fragmentRef.length === 0) {\n                    this._result = { data: [], snapshot: [] };\n                }\n            }\n\n            if (!this._result) {\n                this._selector = getSelector(this._fragment, this._fragmentRef);\n                this.lookup();\n            }\n        }\n    }\n\n    lookup(): void {\n        const snapshot = lookupFragment(this._environment, this._selector);\n\n        // if (!isMissingData(snapshot)) { this for promises\n        this._result = getFragmentResult(snapshot);\n        this.subscribe();\n    }\n\n    getData(): any | null {\n        return this._result ? this._result.data : null;\n    }\n\n    subscribe(): void {\n        const environment = this._environment;\n        const renderedSnapshot = this._result.snapshot;\n\n        this._disposable && this._disposable.dispose();\n        if (!renderedSnapshot) {\n            this._disposable = { dispose: (): void => {} };\n        }\n\n        const dataSubscriptions = [];\n\n        if (Array.isArray(renderedSnapshot)) {\n            renderedSnapshot.forEach((snapshot, idx) => {\n                dataSubscriptions.push(\n                    environment.subscribe(snapshot, (latestSnapshot) => {\n                        this._result.snapshot[idx] = latestSnapshot;\n                        this._result.data[idx] = latestSnapshot.data;\n                        this.refreshHooks();\n                    }),\n                );\n            });\n        } else {\n            dataSubscriptions.push(\n                environment.subscribe(renderedSnapshot, (latestSnapshot) => {\n                    this._result = getFragmentResult(latestSnapshot);\n                    this.refreshHooks();\n                }),\n            );\n        }\n\n        this._disposable = {\n            dispose: (): void => {\n                dataSubscriptions.map((s) => s.dispose());\n            },\n        };\n    }\n\n    changeVariables(variables, request): void {\n        if (this._selector.kind === 'PluralReaderSelector') {\n            (this._selector as any).selectors = (this\n                ._selector as PluralReaderSelector).selectors.map((s) =>\n                getNewSelector(request, s, variables),\n            );\n        } else {\n            this._selector = getNewSelector(request, this._selector, variables);\n        }\n        this.lookup();\n    }\n\n    lookupInStore(environment: IEnvironment, operation, fetchPolicy): Snapshot | null {\n        if (isStorePolicy(fetchPolicy)) {\n            const check: any = environment.check(operation);\n            if (check === 'available' || check.status === 'available') {\n                this._retainCachedOperation(operation);\n                return environment.lookup(operation.fragment);\n            }\n        }\n        return null;\n    }\n\n    refetch = (\n        taggedNode: GraphQLTaggedNode,\n        refetchVariables: Variables | ((fragmentVariables: Variables) => Variables),\n        renderVariables: Variables,\n        observerOrCallback: ObserverOrCallback,\n        options: RefetchOptions,\n    ): Disposable => {\n        //TODO Function\n        const fragmentVariables = this.getFragmentVariables();\n        const fetchVariables =\n            typeof refetchVariables === 'function'\n                ? refetchVariables(fragmentVariables)\n                : refetchVariables;\n        const newFragmentVariables = renderVariables\n            ? { ...fetchVariables, ...renderVariables }\n            : fetchVariables;\n\n        /*eslint-disable */\n        const observer =\n            typeof observerOrCallback === 'function'\n                ? {\n                      next: observerOrCallback,\n                      error: observerOrCallback,\n                  }\n                : observerOrCallback || ({} as any);\n\n        /*eslint-enable */\n        const onNext = (operation, payload, complete): void => {\n            this.changeVariables(newFragmentVariables, operation.request.node);\n            this.refreshHooks();\n            complete();\n        };\n\n        return this.executeFetcher(taggedNode, fetchVariables, options, observer, onNext);\n    };\n\n    // pagination\n\n    isLoading = (): boolean => {\n        return !!this._refetchSubscription;\n    };\n\n    hasMore = (connectionConfig?: ConnectionConfig): boolean => {\n        this.paginationData = getPaginationData(this.paginationData, this._fragment);\n        const connectionData = _getConnectionData(\n            this.paginationData,\n            this.getData(),\n            connectionConfig,\n        );\n        return !!(connectionData && connectionData.hasMore && connectionData.cursor);\n    };\n\n    refetchConnection = (\n        connectionConfig: ConnectionConfig,\n        totalCount: number,\n        observerOrCallback?: ObserverOrCallback,\n        refetchVariables?: Variables,\n    ): Disposable => {\n        this.paginationData = getPaginationData(this.paginationData, this._fragment);\n\n        this._refetchVariables = refetchVariables;\n        const paginatingVariables = {\n            count: totalCount,\n            cursor: null,\n            totalCount,\n        };\n        return this._fetchPage(\n            connectionConfig,\n            paginatingVariables,\n            toObserver(observerOrCallback),\n            { force: true },\n        );\n    };\n\n    loadMore = (\n        connectionConfig: ConnectionConfig,\n        pageSize: number,\n        observerOrCallback?: ObserverOrCallback,\n        options?: RefetchOptions,\n    ): Disposable => {\n        this.paginationData = getPaginationData(this.paginationData, this._fragment);\n\n        const observer = toObserver(observerOrCallback);\n        const connectionData = _getConnectionData(\n            this.paginationData,\n            this.getData(),\n            connectionConfig,\n        );\n\n        if (!connectionData) {\n            Observable.create((sink) => sink.complete()).subscribe(observer);\n            return null;\n        }\n        const totalCount = connectionData.edgeCount + pageSize;\n        if (options && options.force) {\n            return this.refetchConnection(\n                connectionConfig,\n                totalCount,\n                observerOrCallback,\n                undefined,\n            );\n        }\n        //const { END_CURSOR, START_CURSOR } = ConnectionInterface.get();\n        const cursor = connectionData.cursor;\n        /*warning(\n            cursor,\n            'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)',\n            this._direction === FORWARD ? END_CURSOR : START_CURSOR,\n            cursor,\n        );*/\n        const paginatingVariables = {\n            count: pageSize,\n            cursor: cursor,\n            totalCount,\n        };\n        return this._fetchPage(connectionConfig, paginatingVariables, observer, options);\n    };\n\n    _fetchPage(\n        connectionConfig: ConnectionConfig,\n        paginatingVariables: {\n            count: number;\n            cursor: string;\n            totalCount: number;\n        },\n        observer: Observer<void>,\n        options: RefetchOptions,\n    ): Disposable {\n        //const { componentRef: _, __relayContext, ...restProps } = this.props;\n        //const resolver = prevResult.resolver;\n        //const fragments = prevResult.resolver._fragments;\n        const rootVariables = getRootVariablesForSelector(this._selector);\n        // hack 6.0.0\n        let fragmentVariables = {\n            ...rootVariables,\n            ...this.getFragmentVariables(),\n            ...this._refetchVariables,\n        };\n        let fetchVariables = connectionConfig.getVariables(\n            this.getData(),\n            {\n                count: paginatingVariables.count,\n                cursor: paginatingVariables.cursor,\n            },\n            fragmentVariables,\n        );\n        invariant(\n            typeof fetchVariables === 'object' && fetchVariables !== null,\n            'ReactRelayPaginationContainer: Expected `getVariables()` to ' +\n                'return an object, got `%s` in `%s`.',\n            fetchVariables,\n            'useFragment pagination',\n        );\n        fetchVariables = {\n            ...fetchVariables,\n            ...this._refetchVariables,\n        };\n        fragmentVariables = {\n            ...fetchVariables,\n            ...fragmentVariables,\n        };\n\n        const onNext = (operation, payload, complete): void => {\n            const prevData = this.getData();\n\n            const getFragmentVariables =\n                connectionConfig.getFragmentVariables || this.paginationData.getFragmentVariables;\n            this.changeVariables(\n                getFragmentVariables(fragmentVariables, paginatingVariables.totalCount),\n                operation.request.node,\n            );\n\n            const nextData = this.getData();\n\n            // Workaround slightly different handling for connection in different\n            // core implementations:\n            // - Classic core requires the count to be explicitly incremented\n            // - Modern core automatically appends new items, updating the count\n            //   isn't required to see new data.\n            //\n            // `setState` is only required if changing the variables would change the\n            // resolved data.\n            // TODO #14894725: remove PaginationContainer equal check\n\n            if (!areEqual(prevData, nextData)) {\n                this.refreshHooks();\n                const callComplete = async (): Promise<void> => {\n                    complete();\n                };\n                callComplete();\n            } else {\n                complete();\n            }\n        };\n\n        return this.executeFetcher(\n            connectionConfig.query,\n            fetchVariables,\n            options,\n            observer,\n            onNext,\n        );\n    }\n\n    executeFetcher(\n        taggedNode: GraphQLTaggedNode,\n        fetchVariables: Variables,\n        options: RefetchOptions,\n        observerOrCallback: ObserverOrCallback,\n        onNext: (operation, payload, complete) => void,\n    ): Disposable {\n        const cacheConfig: CacheConfig = options ? { force: !!options.force } : undefined;\n        if (cacheConfig != null && options && options.metadata != null) {\n            cacheConfig.metadata = options.metadata;\n        }\n\n        /*eslint-disable */\n        const observer =\n            typeof observerOrCallback === 'function'\n                ? {\n                      next: observerOrCallback,\n                      error: observerOrCallback,\n                  }\n                : observerOrCallback || ({} as any);\n\n        /*eslint-enable */\n\n        const operation = createOperation(taggedNode, fetchVariables);\n\n        const optionsFetch = options ? options : {};\n\n        const { fetchPolicy = 'network-only' } = optionsFetch;\n\n        const storeSnapshot = this.lookupInStore(this._environment, operation, fetchPolicy);\n        if (storeSnapshot != null) {\n            onNext(operation, null, () => {\n                observer.next && observer.next();\n                observer.complete && observer.complete();\n            });\n        }\n        // Cancel any previously running refetch.\n        this._refetchSubscription && this._refetchSubscription.unsubscribe();\n\n        // Declare refetchSubscription before assigning it in .start(), since\n        // synchronous completion may call callbacks .subscribe() returns.\n        let refetchSubscription: Subscription;\n\n        const isNetwork = isNetworkPolicy(fetchPolicy, storeSnapshot);\n        if (!isNetwork) {\n            return {\n                dispose: (): void => {},\n            };\n        }\n        if (isNetwork) {\n            const reference = this._environment.retain(operation);\n\n            /*eslint-disable */\n            const fetchQueryOptions =\n                cacheConfig != null\n                    ? {\n                          networkCacheConfig: cacheConfig,\n                      }\n                    : {};\n\n            /*eslint-enable */\n            const cleanup = (): void => {\n                this._selectionReferences = this._selectionReferences.concat(reference);\n                if (this._refetchSubscription === refetchSubscription) {\n                    this._refetchSubscription = null;\n                    this._isARequestInFlight = false;\n                }\n            };\n\n            this._isARequestInFlight = true;\n            fetchQuery(this._environment, operation, fetchQueryOptions)\n                .mergeMap((payload) => {\n                    return Observable.create((sink) => {\n                        onNext(operation, payload, () => {\n                            sink.next(undefined); // pass void to public observer's `next()`\n                            sink.complete();\n                        });\n                    });\n                })\n                // use do instead of finally so that observer's `complete` fires after cleanup\n                .do({\n                    error: cleanup,\n                    complete: cleanup,\n                    unsubscribe: cleanup,\n                })\n                .subscribe({\n                    ...observer,\n                    start: (subscription) => {\n                        refetchSubscription = subscription;\n                        this._refetchSubscription = this._isARequestInFlight\n                            ? refetchSubscription\n                            : null;\n                        observer.start && observer.start(subscription);\n                    },\n                });\n        }\n\n        return {\n            dispose: (): void => {\n                refetchSubscription && refetchSubscription.unsubscribe();\n            },\n        };\n    }\n}\n","import { useEffect, useState, useRef } from 'react';\nimport { GraphQLTaggedNode } from 'relay-runtime';\nimport { FragmentResolver } from './FragmentResolver';\nimport {\n    ContainerResult,\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n} from './RelayHooksType';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport function useOssFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [$Call<KeyReturnType<TKey>>, FragmentResolver];\nexport function useOssFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [$Call<KeyReturnType<TKey>> | null, FragmentResolver];\nexport function useOssFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>, FragmentResolver];\nexport function useOssFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null, FragmentResolver] {\n    const environment = useRelayEnvironment();\n    const [, forceUpdate] = useState<ContainerResult>(null);\n    const ref = useRef<{ resolver: FragmentResolver }>(null);\n    if (ref.current === null || ref.current === undefined) {\n        ref.current = {\n            resolver: new FragmentResolver(forceUpdate),\n        };\n    }\n\n    const { resolver } = ref.current;\n\n    useEffect(() => {\n        return (): void => {\n            resolver.dispose();\n        };\n    }, [resolver]);\n\n    resolver.resolve(environment, fragmentNode, fragmentRef);\n\n    const data = resolver.getData();\n\n    return [data, resolver];\n}\n","/*eslint-disable */\nimport * as invariant from 'fbjs/lib/invariant';\nimport * as React from 'react';\nimport { Environment, MutationParameters, commitMutation } from 'relay-runtime';\nimport useMounted from '@restart/hooks/useMounted';\nimport {\n    MutationNode,\n    MutationConfig,\n    MutationState,\n    Mutate,\n    MutationProps,\n} from './RelayHooksType';\nimport { useRelayEnvironment } from './useRelayEnvironment';\nconst { useCallback, useState } = React;\n\nexport function useMutation<T extends MutationParameters>(\n    mutation: MutationNode<T>,\n    userConfig: MutationConfig<T> = {},\n    /** if not provided, the context environment will be used. */\n    environment?: Environment,\n): [Mutate<T>, MutationState<T>] {\n    const [state, setState] = useState<MutationState<T>>({\n        loading: false,\n        data: null,\n        error: null,\n    });\n\n    const isMounted = useMounted();\n\n    const relayEnvironment = useRelayEnvironment();\n    const resolvedEnvironment = environment || relayEnvironment;\n    const {\n        configs,\n        variables,\n        uploadables,\n        onCompleted,\n        onError,\n        optimisticUpdater,\n        optimisticResponse,\n        updater,\n    } = userConfig;\n\n    const mutate: Mutate<T> = useCallback(\n        (config) => {\n            const mergedConfig = {\n                configs,\n                variables,\n                uploadables,\n                onCompleted,\n                onError,\n                optimisticUpdater,\n                optimisticResponse,\n                updater,\n                ...config,\n            };\n\n            invariant(mergedConfig.variables, 'you must specify variables');\n\n            setState({\n                loading: true,\n                data: null,\n                error: null,\n            });\n\n            return new Promise((resolve, reject) => {\n                function handleError(error: any): void {\n                    if (isMounted()) {\n                        setState({\n                            loading: false,\n                            data: null,\n                            error,\n                        });\n                    }\n\n                    if (mergedConfig.onError) {\n                        mergedConfig.onError(error);\n                        resolve();\n                    } else {\n                        reject(error);\n                    }\n                }\n\n                commitMutation(resolvedEnvironment, {\n                    ...mergedConfig,\n                    mutation,\n                    variables: mergedConfig.variables!,\n                    onCompleted: (response, errors) => {\n                        if (errors) {\n                            // FIXME: This isn't right. onError expects a single error.\n                            handleError(errors);\n                            return;\n                        }\n\n                        if (isMounted()) {\n                            setState({\n                                loading: false,\n                                data: response,\n                                error: null,\n                            });\n                        }\n\n                        if (mergedConfig.onCompleted) {\n                            mergedConfig.onCompleted(response);\n                        }\n                        resolve(response);\n                    },\n                    onError: handleError,\n                });\n            });\n        },\n        [\n            resolvedEnvironment,\n            configs,\n            mutation,\n            variables,\n            uploadables,\n            onCompleted,\n            onError,\n            optimisticUpdater,\n            optimisticResponse,\n            updater,\n            isMounted,\n        ],\n    );\n\n    return [mutate, state];\n}\n\nexport function Mutation<T extends MutationParameters>({\n    children,\n    mutation,\n    environment,\n    ...config\n}: MutationProps<T>) {\n    const [mutate, state] = useMutation(mutation, config, environment);\n    return children(mutate, state) as React.ReactElement;\n}\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport {\n    RefetchFunction,\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n} from './RelayHooksType';\nimport { useOssFragment } from './useOssFragment';\n\nexport function useRefetch<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [$Call<KeyReturnType<TKey>>, RefetchFunction<TOperationType['variables']>];\nexport function useRefetch<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [$Call<KeyReturnType<TKey>> | null, RefetchFunction<TOperationType['variables']>];\nexport function useRefetch<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>, RefetchFunction<TOperationType['variables']>];\nexport function useRefetch<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null,\n    RefetchFunction<TOperationType['variables']>,\n] {\n    const [data, { refetch }] = useOssFragment(fragmentNode, fragmentRef);\n\n    return [data, refetch];\n}\n","import * as React from 'react';\nimport { Environment } from 'relay-runtime';\nimport { ReactRelayContext } from './ReactRelayContext'; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nexport const RelayEnvironmentProvider = function<\n    TEnvironment extends Environment = Environment\n>(props: { children: React.ReactNode; environment: TEnvironment }): JSX.Element {\n    const context = React.useMemo(() => ({ environment: props.environment }), [props.environment]);\n    return (\n        <ReactRelayContext.Provider value={context}>{props.children}</ReactRelayContext.Provider>\n    );\n};\n","import { GraphQLTaggedNode } from 'relay-runtime';\nimport { KeyType, KeyReturnType, $Call, ArrayKeyType, ArrayKeyReturnType } from './RelayHooksType';\nimport { useOssFragment } from './useOssFragment';\n\nexport function useFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): $Call<KeyReturnType<TKey>>;\nexport function useFragment<TKey extends KeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): $Call<KeyReturnType<TKey>> | null;\nexport function useFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>;\nexport function useFragment<TKey extends ArrayKeyType>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> {\n    const [data] = useOssFragment(fragmentNode, fragmentRef);\n\n    return data;\n}\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport { RenderProps, QueryOptions } from './RelayHooksType';\nimport { useMemoOperationDescriptor } from './useQuery';\nimport { useQueryFetcher } from './useQueryFetcher';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport const useLazyLoadQuery = <TOperationType extends OperationType = OperationType>(\n    gqlQuery: GraphQLTaggedNode,\n    variables: TOperationType['variables'] = {},\n    options: QueryOptions = {},\n): RenderProps<TOperationType> => {\n    const environment = useRelayEnvironment();\n    const query = useMemoOperationDescriptor(gqlQuery, variables);\n    const queryFetcher = useQueryFetcher<TOperationType>(query);\n    return queryFetcher.execute(environment, query, options);\n};\n","import { useMemo } from 'react';\nimport { GraphQLTaggedNode, OperationType } from 'relay-runtime';\nimport {\n    PaginationFunction,\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n} from './RelayHooksType';\nimport { useOssFragment } from './useOssFragment';\n\nexport function usePagination<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [\n    $Call<KeyReturnType<TKey>>,\n    PaginationFunction<$Call<KeyReturnType<TKey>>, TOperationType['variables']>,\n];\nexport function usePagination<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [\n    $Call<KeyReturnType<TKey>> | null,\n    PaginationFunction<$Call<KeyReturnType<TKey>> | null, TOperationType['variables']>,\n];\nexport function usePagination<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>,\n    PaginationFunction<ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>, TOperationType['variables']>,\n];\nexport function usePagination<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentNode: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null,\n    PaginationFunction<\n        ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null,\n        TOperationType['variables']\n    >,\n] {\n    const [data, resolver] = useOssFragment(fragmentNode, fragmentRef);\n\n    const fns = useMemo(() => {\n        return {\n            loadMore: resolver.loadMore,\n            hasMore: resolver.hasMore,\n            isLoading: resolver.isLoading,\n            refetchConnection: resolver.refetchConnection,\n        };\n    }, [resolver]);\n\n    return [data, fns];\n}\n","import { useState, useEffect } from 'react';\nimport { OperationType } from 'relay-runtime';\nimport { RenderProps, LoadQuery } from './RelayHooksType';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport const usePreloadedQuery = <TOperationType extends OperationType = OperationType>(\n    loadQuery: LoadQuery,\n): RenderProps<TOperationType> => {\n    const [, forceUpdate] = useState();\n    const environment = useRelayEnvironment();\n\n    useEffect(() => {\n        const dispose = loadQuery.subscribe(forceUpdate);\n        return (): void => dispose();\n    }, [loadQuery]);\n\n    return loadQuery.getValue(environment) as RenderProps<TOperationType>;\n};\n","import * as invariant from 'fbjs/lib/invariant';\nimport { useCallback, useMemo } from 'react';\nimport { GraphQLTaggedNode, getFragment, OperationType, ConcreteRequest } from 'relay-runtime';\nimport {\n    RefetchableFunction,\n    RefetchOptions,\n    KeyType,\n    KeyReturnType,\n    $Call,\n    ArrayKeyType,\n    ArrayKeyReturnType,\n    ObserverOrCallback,\n} from './RelayHooksType';\nimport { useRefetch } from './useRefetch';\n\nexport function useRefetchable<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [$Call<KeyReturnType<TKey>>, RefetchableFunction<TOperationType['variables']>];\nexport function useRefetchable<\n    TKey extends KeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [$Call<KeyReturnType<TKey>> | null, RefetchableFunction<TOperationType['variables']>];\nexport function useRefetchable<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>,\n    RefetchableFunction<TOperationType['variables']>,\n];\nexport function useRefetchable<\n    TKey extends ArrayKeyType,\n    TOperationType extends OperationType = OperationType\n>(\n    fragmentInput: GraphQLTaggedNode,\n    fragmentRef: TKey | null,\n): [\n    ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> | null,\n    RefetchableFunction<TOperationType['variables']>,\n] {\n    const [data, refetch] = useRefetch(fragmentInput, fragmentRef);\n\n    const refetchNode = useMemo(() => {\n        const fragmentNode = getFragment(fragmentInput);\n        const metadata = fragmentNode.metadata;\n        invariant(\n            metadata != null,\n            'useRefetchable: Expected fragment `%s` to be refetchable when using `%s`. ' +\n                'Did you forget to add a @refetchable directive to the fragment?',\n            'useRefetchable',\n            fragmentNode.name,\n        );\n        const isPlural = metadata.plural;\n        invariant(\n            isPlural !== true,\n            'useRefetchable: Expected fragment `%s` not to be plural when using ' +\n                '`%s`. Remove `@relay(plural: true)` from fragment `%s` ' +\n                'in order to use it with `%s`.',\n            fragmentNode.name,\n            'useRefetchable',\n            fragmentNode.name,\n            'useRefetchable',\n        );\n\n        const refetchMetadata = metadata.refetch;\n        invariant(\n            refetchMetadata != null,\n            'useRefetchable: Expected fragment `%s` to be refetchable when using `%s`. ' +\n                'Did you forget to add a @refetchable directive to the fragment?',\n            'useRefetchable',\n            fragmentNode.name,\n        );\n\n        // handle both commonjs and es modules\n        const refetchableRequest: ConcreteRequest = (refetchMetadata as any).operation.default\n            ? (refetchMetadata as any).operation.default\n            : refetchMetadata.operation;\n\n        return refetchableRequest;\n    }, [fragmentInput]);\n\n    const refetchable = useCallback(\n        (\n            refetchVariables:\n                | TOperationType['variables']\n                | ((fragmentVariables: TOperationType['variables']) => TOperationType['variables']),\n            options: {\n                renderVariables?: TOperationType['variables'];\n                observerOrCallback?: ObserverOrCallback;\n                refetchOptions?: RefetchOptions;\n            } = {},\n        ) => {\n            return refetch(\n                refetchNode,\n                refetchVariables,\n                options.renderVariables,\n                options.observerOrCallback,\n                options.refetchOptions,\n            );\n        },\n        [refetch, refetchNode],\n    );\n\n    return [data, refetchable];\n}\n","import { useEffect } from 'react';\nimport { GraphQLSubscriptionConfig, requestSubscription, OperationType } from 'relay-runtime';\nimport { useRelayEnvironment } from './useRelayEnvironment';\n\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\n    config: GraphQLSubscriptionConfig<TSubscriptionPayload>,\n): void {\n    const environment = useRelayEnvironment();\n\n    useEffect(() => {\n        const { dispose } = requestSubscription(environment, config);\n        return dispose;\n    }, [environment, config]);\n}\n"],"names":["ReactRelayContext","createRelayContext","React","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","isNetworkPolicy","policy","storeSnapshot","isStorePolicy","createOperation","gqlQuery","variables","createOperationDescriptor","getRequest","toObserver","observerOrCallback","error","complete","unsubscribe","subscription","getPaginationData","paginationData","fragment","metadata","foundConnectionMetadata","isRelayModern","connectionMetadata","connection","undefined","invariant","name","fragmentName","findConnectionMetadata","getConnectionFromProps","path","props","data","createGetConnectionFromProps","direction","getFragmentVariables","countVariable","count","prevVars","totalCount","createGetFragmentVariables","getNewSelector","request","areEqual","requestDescriptor","createRequestDescriptor","createReaderSelector","node","dataID","_getConnectionData","_a","connectionConfig","connectionData","_b","EDGES","PAGE_INFO","HAS_NEXT_PAGE","HAS_PREV_PAGE","END_CURSOR","START_CURSOR","edges","pageInfo","Array","isArray","hasMore","cursor","warning","edgeCount","fetchQuery","cache","Map","getOrCreateQueryFetcher","query","forceUpdate","suspense","queryFetcher","has","identifier","get","QueryFetcher","setForceUpdate","useLazy","disposeRequest","disposeRetain","clearTemporaryRetain","disposableRetain","dispose","delete","clearTimeout","releaseQueryTimeout","setTimeout","_this","environment","operation","fetchPolicy","check","status","lookup","options","retain","networkCacheConfig","fetchKey","fetchObserver","retry","cacheConfigOverride","observer","fetch","cached","isDiffEnvQuery","set","lookupInStore","snapshot","subscribe","resultSnapshot","rootSubscription","fetchHasReturned","resolveNetworkPromise","force","start","networkSubscription","next","_onQueryDataAvailable","notifyFirstResult","temporaryRetain","Promise","resolve","useQueryFetcher","ref","useRef","current","useEffect","useRelayEnvironment","useMemoOperationDescriptor","value","latestValue","memoVariables","useMemo","internalLoadQuery","promise","queryExecute","execute","listener","prev","result","e","then","callback","getValue","isPromise","getFragmentResult","map","taggedNode","refetchVariables","renderVariables","fragmentVariables","fetchVariables","newFragmentVariables","executeFetcher","payload","changeVariables","refreshHooks","_refetchSubscription","_fragment","getData","_refetchVariables","_fetchPage","pageSize","Observable","create","sink","refetchConnection","_forceUpdate","FragmentResolver","indexUpdate","_disposable","disposeSelectionReferences","_isARequestInFlight","_disposeCacheSelectionReference","_selectionReferences","forEach","r","_cacheSelectionReference","_environment","fRef","_fragmentRef","getVariablesFromFragment","fragmentRef","prevIDs","getDataIDsFromFragment","nextIDs","fragmentNode","_fragmentNode","getFragment","changedFragmentRef","_result","_isPlural","plural","_selector","getSelector","selector","kind","selectors","renderedSnapshot","dataSubscriptions","idx","push","latestSnapshot","_retainCachedOperation","paginatingVariables","rootVariables","owner","getVariables","prevData","thisArg","P","generator","nextData","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","TypeError","done","pop","step","reject","fulfilled","rejected","onNext","cacheConfig","refetchSubscription","isNetwork","reference_1","fetchQueryOptions","cleanup","concat","mergeMap","do","useOssFragment","resolver","useCallback","useState","useRefetch","context","Provider","children","mutation","userConfig","state","setState","isMounted","useMounted","relayEnvironment","resolvedEnvironment","configs","uploadables","onCompleted","onError","optimisticUpdater","optimisticResponse","updater","config","mergedConfig","loading","handleError","commitMutation","response","errors","loadMore","isLoading","loadQuery","fragmentInput","refetch","refetchNode","refetchMetadata","default","refetchOptions"],"mappings":"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"}